"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("./common");
var legacy_1 = require("./legacy");
var new_1 = require("./new");
/**
 * Evaluate the getter function and cache the result
 * @param {boolean} [setProto=false] Set the value on the class prototype as well. Only applies to non-static getters.
 * @param {boolean} [makeNonConfigurable=false] Set to true to make the resolved property non-configurable
 * @param {ResultSelectorFn} [resultSelector] A filter function that must return true for the value to cached
 * @return A decorator function
 */
function LazyGetter(setProto, makeNonConfigurable, resultSelector) {
    if (resultSelector === void 0) { resultSelector = common_1.defaultFilter; }
    var desc;
    var prop;
    var args = null;
    var isLegacy;
    function decorator(targetOrDesc, key, descriptor) {
        args = arguments;
        if (key === undefined) {
            if (typeof desc === 'undefined') {
                isLegacy = false;
                prop = targetOrDesc.key;
                desc = Object.assign({}, targetOrDesc.descriptor || /* istanbul ignore next */ targetOrDesc);
            }
            return new_1.decorateNew(targetOrDesc, setProto, makeNonConfigurable, resultSelector);
        }
        else {
            if (typeof desc === 'undefined') {
                isLegacy = true;
                prop = key;
                desc = Object.assign({}, descriptor || /* istanbul ignore next */ Object.getOwnPropertyDescriptor(targetOrDesc, key));
            }
            return legacy_1.decorateLegacy(targetOrDesc, key, descriptor, setProto, makeNonConfigurable, resultSelector);
        }
    }
    decorator.reset = setProto ? thrower : function (on) {
        if (!on) {
            throw new Error('Unable to restore descriptor on an undefined target');
        }
        if (!desc) {
            throw new Error('Unable to restore descriptor. Did you remember to apply your decorator to a method?');
        }
        // Restore descriptor to its original state
        Object.defineProperty(on, prop, desc);
        var ret = decorator.apply(null, args);
        Object.defineProperty(on, prop, isLegacy ? ret : (ret.descriptor || ret));
    };
    return decorator;
}
exports.LazyGetter = LazyGetter;
function thrower() {
    throw new Error('This decoration modifies the class prototype and cannot be reset.');
}
//# sourceMappingURL=LazyGetter.js.map