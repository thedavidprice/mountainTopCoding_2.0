import { Platform } from '@prisma/get-platform';
import type { Engine, EngineConfig, EngineEventType, GetConfigResult } from './Engine';
declare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';
declare type QueryEngineConfig = {
    datamodel: string;
    datasourceOverrides?: Record<string, string>;
    logLevel: QueryEngineLogLevel;
    telemetry?: QueryEngineTelemetry;
};
declare type QueryEngineTelemetry = {
    enabled: Boolean;
    endpoint: string;
};
export interface QueryEngineConstructor {
    new (config: QueryEngineConfig, logger: (err: string, log: string) => void): QueryEngine;
}
declare type ConnectArgs = {
    enableRawQueries: boolean;
};
export declare type QueryEngineRequest = {
    query: string;
    variables: Object;
};
export declare type QueryEngineRequestHeaders = {
    traceparent?: string;
};
export declare type QueryEngineBatchRequest = {
    batch: QueryEngineRequest[];
    transaction: boolean;
};
export declare type QueryEngine = {
    connect(connectArgs: ConnectArgs): Promise<void>;
    disconnect(): Promise<void>;
    getConfig(): Promise<string>;
    dmmf(): Promise<string>;
    query(request: QueryEngineRequest | QueryEngineBatchRequest, headers: QueryEngineRequestHeaders): Promise<string>;
    sdlSchema(): Promise<string>;
    serverInfo(): Promise<string>;
    nextLogEvent(): Promise<string>;
};
declare type ServerInfo = {
    commit: string;
    version: string;
    primaryConnector: string;
};
export declare class NAPIEngine implements Engine {
    private engine?;
    private setupPromise?;
    private connectPromise?;
    private disconnectPromise?;
    private currentQuery?;
    private config;
    private QueryEngine?;
    private logEmitter;
    libQueryEnginePath?: string;
    platform?: Platform;
    datasourceOverrides: Record<string, string>;
    datamodel: string;
    logQueries: boolean;
    logLevel: QueryEngineLogLevel;
    lastQuery?: string;
    lastError?: any;
    connected: boolean;
    beforeExitListener?: (args?: any) => any;
    serverInfo?: ServerInfo;
    constructor(config: EngineConfig);
    private internalSetup;
    private getPlatform;
    private parseEngineResponse;
    private convertDatasources;
    private loadEngine;
    private logger;
    private getErrorMessageWithLink;
    private parseInitError;
    private parseRequestError;
    on(event: EngineEventType, listener: (args?: any) => any): void;
    emitExit(): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    kill(signal: string): void;
    getConfig(): Promise<GetConfigResult>;
    version(forceRun?: boolean): Promise<string>;
    private graphQLToJSError;
    request<T>(query: string, headers: Record<string, string>, numTry: number): Promise<{
        data: T;
        elapsed: number;
    }>;
    requestBatch(queries: string[], transaction?: boolean, numTry?: number): Promise<any>;
    private resolveEnginePath;
    private getLibQueryEnginePath;
    private getFixedGenerator;
}
export {};
