"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NAPIEngine = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const engines_1 = require("@prisma/engines");
const get_platform_1 = require("@prisma/get-platform");
const chalk_1 = __importDefault(require("chalk"));
const events_1 = __importDefault(require("events"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const errors_1 = require("./errors");
const printGeneratorConfig_1 = require("./printGeneratorConfig");
const util_1 = require("./util");
const debug = debug_1.default('prisma:client:napi');
const MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
function isQueryEvent(event) {
    return event.level === 'info' && event['item_type'] === 'query';
}
function isPanicEvent(event) {
    return event.level === 'error' && event['message'] === 'PANIC';
}
const knownPlatforms = [...get_platform_1.platforms, 'native'];
class NAPIEngine {
    constructor(config) {
        var _a, _b;
        this.datamodel = fs_1.default.readFileSync(config.datamodelPath, 'utf-8');
        this.config = config;
        this.connected = false;
        this.logQueries = (_a = config.logQueries) !== null && _a !== void 0 ? _a : false;
        this.logLevel = (_b = config.logLevel) !== null && _b !== void 0 ? _b : 'error';
        this.logEmitter = new events_1.default();
        this.logEmitter.on('error', (e) => {
            // to prevent unhandled error events
        });
        this.datasourceOverrides = config.datasources
            ? this.convertDatasources(config.datasources)
            : {};
        if (this.logQueries) {
            process.env.LOG_QUERIES = 'true';
            this.logLevel = 'info';
        }
        if (config.enableEngineDebugMode) {
            this.logLevel = 'debug';
            // Debug.enable('*')
        }
        this.setupPromise = this.internalSetup();
    }
    async internalSetup() {
        debug('internalSetup');
        if (this.setupPromise)
            return this.setupPromise;
        this.platform = await this.getPlatform();
        this.libQueryEnginePath = await this.getLibQueryEnginePath();
        await this.loadEngine();
        await this.version();
    }
    async getPlatform() {
        if (this.platform)
            return this.platform;
        const platform = await get_platform_1.getPlatform();
        if (!knownPlatforms.includes(platform)) {
            throw new errors_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red('PRISMA_QUERY_ENGINE_LIBRARY')} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(', '))} or a path to the query engine library.
You may have to run ${chalk_1.default.greenBright('prisma generate')} for your changes to take effect.`, this.config.clientVersion);
        }
        return platform;
    }
    parseEngineResponse(response) {
        try {
            const config = JSON.parse(response);
            return config;
        }
        catch (err) {
            throw new errors_1.PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
        }
    }
    convertDatasources(datasources) {
        const obj = Object.create(null);
        for (const { name, url } of datasources) {
            obj[name] = url;
        }
        return obj;
    }
    async loadEngine() {
        debug('loadEngine');
        if (!this.engine) {
            if (!this.QueryEngine) {
                if (!this.libQueryEnginePath) {
                    this.libQueryEnginePath = await this.getLibQueryEnginePath();
                    debug(`using ${this.libQueryEnginePath}`);
                }
                try {
                    // this require needs to be resolved at runtime, tell webpack to ignore it
                    this.QueryEngine = eval('require')(this.libQueryEnginePath).QueryEngine;
                }
                catch (e) {
                    if (fs_1.default.existsSync(this.libQueryEnginePath)) {
                        throw new errors_1.PrismaClientInitializationError(`Unable to load NAPI Library from ${chalk_1.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
                    }
                    else {
                        throw new errors_1.PrismaClientInitializationError(`Unable to load NAPI Library from ${chalk_1.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
                    }
                }
            }
            if (this.QueryEngine) {
                try {
                    this.engine = new this.QueryEngine({
                        datamodel: this.datamodel,
                        datasourceOverrides: this.datasourceOverrides,
                        logLevel: this.logLevel,
                        configDir: this.config.cwd,
                    }, (err, log) => this.logger(err, log));
                }
                catch (e) {
                    const error = this.parseInitError(e.message);
                    if (typeof error === 'string') {
                        throw e;
                    }
                    else {
                        throw new errors_1.PrismaClientInitializationError(error.message, this.config.clientVersion, error.error_code);
                    }
                }
            }
        }
    }
    logger(err, log) {
        var _a;
        if (err) {
            throw err;
        }
        const event = this.parseEngineResponse(log);
        if (!event)
            return;
        event.level = (_a = event === null || event === void 0 ? void 0 : event.level.toLowerCase()) !== null && _a !== void 0 ? _a : 'unknown';
        if (isQueryEvent(event)) {
            this.logEmitter.emit('query', {
                timestamp: Date.now(),
                query: event.query,
                params: event.params,
                duration: event.duration_ms,
                target: event.module_path,
            });
        }
        else if (isPanicEvent(event)) {
            this.lastError = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
            this.logEmitter.emit('error', this.lastError);
        }
        else {
            this.logEmitter.emit(event.level, event);
        }
    }
    getErrorMessageWithLink(title) {
        var _a, _b;
        return errors_1.getErrorMessageWithLink({
            platform: this.platform,
            title,
            version: this.config.clientVersion,
            engineVersion: (_a = this.serverInfo) === null || _a === void 0 ? void 0 : _a.version,
            database: (_b = this.serverInfo) === null || _b === void 0 ? void 0 : _b.primaryConnector,
            query: this.lastQuery,
        });
    }
    parseInitError(str) {
        try {
            const error = JSON.parse(str);
            if (typeof error.is_panic !== 'undefined') {
                return error;
            }
        }
        catch (e) {
            //
        }
        return str;
    }
    parseRequestError(str) {
        try {
            const error = JSON.parse(str);
            if (typeof error.is_panic !== 'undefined') {
                return error;
            }
        }
        catch (e) {
            //
        }
        return str;
    }
    on(event, listener) {
        if (event === 'beforeExit') {
            this.beforeExitListener = listener;
        }
        else {
            this.logEmitter.on(event, listener);
        }
    }
    async emitExit() {
        await this.currentQuery;
        debug('emitExit');
        if (this.beforeExitListener) {
            try {
                await this.beforeExitListener();
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    async start() {
        await this.setupPromise;
        await this.disconnectPromise;
        if (this.connectPromise) {
            debug(`already starting: ${this.connected}`);
            await this.connectPromise;
            if (this.connected) {
                return;
            }
        }
        if (!this.connected) {
            // eslint-disable-next-line no-async-promise-executor
            this.connectPromise = new Promise(async (res) => {
                var _a;
                debug('starting');
                await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.connect({ enableRawQueries: true }));
                this.connected = true;
                debug('started');
                res();
            });
            return this.connectPromise;
        }
    }
    async stop() {
        await this.connectPromise;
        await this.currentQuery;
        debug(`stop state ${this.connected}`);
        if (this.disconnectPromise) {
            debug('engine is already disconnecting');
            await this.disconnectPromise;
            if (!this.connected) {
                this.disconnectPromise = undefined;
                return;
            }
        }
        if (this.connected) {
            // eslint-disable-next-line no-async-promise-executor
            this.disconnectPromise = new Promise(async (res) => {
                var _a;
                await this.emitExit();
                debug('disconnect called');
                await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.disconnect());
                this.connected = false;
                debug('disconnect resolved');
                res();
            });
        }
        return this.disconnectPromise;
    }
    kill(signal) {
        if (this.connected && !this.disconnectPromise) {
            // eslint-disable-next-line no-async-promise-executor
            this.disconnectPromise = new Promise(async (res) => {
                var _a;
                await this.emitExit();
                debug(`disconnect called with kill signal ${signal}`);
                await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.disconnect());
                this.connected = false;
                debug(`disconnect resolved`);
                res();
            });
        }
    }
    async getConfig() {
        const config = this.parseEngineResponse(await this.engine.getConfig());
        return config;
    }
    async version(forceRun) {
        const serverInfo = this.parseEngineResponse(await this.engine.serverInfo());
        this.serverInfo = serverInfo;
        return this.serverInfo.version;
    }
    graphQLToJSError(error) {
        debug('graphQLToJSError');
        if (error.user_facing_error.error_code) {
            return new errors_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.config.clientVersion, error.user_facing_error.meta);
        }
        return new errors_1.PrismaClientUnknownRequestError(error.error, this.config.clientVersion);
    }
    async request(query, headers, numTry) {
        try {
            await this.start();
            debug(`request state: ${this.connected}`);
            const request = { query, variables: {} };
            this.lastQuery = JSON.stringify(request);
            this.currentQuery = this.engine.query(request, {});
            const data = this.parseEngineResponse(await this.currentQuery);
            if (data.errors) {
                if (data.errors.length === 1) {
                    throw this.graphQLToJSError(data.errors[0]);
                }
                // this case should not happen, as the query engine only returns one error
                throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
            }
            else if (this.lastError) {
                throw this.lastError;
            }
            return { data, elapsed: 0 };
        }
        catch (e) {
            const error = this.parseRequestError(e.message);
            if (typeof error === 'string') {
                throw e;
            }
            else {
                throw new errors_1.PrismaClientUnknownRequestError(`${error.message}\n${error.backtrace}`, this.config.clientVersion);
            }
        }
    }
    async requestBatch(queries, transaction = false, numTry = 1) {
        await this.start();
        debug('requestBatch');
        const variables = {};
        const request = {
            batch: queries.map((query) => ({ query, variables })),
            transaction,
        };
        this.lastQuery = JSON.stringify(request);
        this.currentQuery = this.engine.query(request, {});
        const result = await this.currentQuery;
        const data = this.parseEngineResponse(result);
        if (data.errors) {
            if (data.errors.length === 1) {
                throw this.graphQLToJSError(data.errors[0]);
            }
            // this case should not happen, as the query engine only returns one error
            throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
        }
        try {
            const { batchResult, errors } = data;
            if (Array.isArray(batchResult)) {
                return batchResult.map((result) => {
                    var _a;
                    if (result.errors) {
                        return (_a = this.lastError) !== null && _a !== void 0 ? _a : this.graphQLToJSError(result.errors[0]);
                    }
                    return {
                        data: result,
                        elapsed: 0,
                    };
                });
            }
            else {
                if (errors && errors.length === 1) {
                    throw new Error(errors[0].error);
                }
                throw new Error(JSON.stringify(data));
            }
        }
        catch (e) {
            // retry
            if (numTry <= MAX_REQUEST_RETRIES) {
                return this.requestBatch(queries, transaction, numTry + 1);
            }
            throw e;
        }
    }
    async resolveEnginePath() {
        var _a, _b, _c, _d;
        const searchedLocations = [];
        let enginePath;
        if (this.libQueryEnginePath) {
            return { enginePath: this.libQueryEnginePath, searchedLocations };
        }
        this.platform = (_a = this.platform) !== null && _a !== void 0 ? _a : (await get_platform_1.getPlatform());
        if (__filename.includes('NAPIEngine')) {
            enginePath = path_1.default.join(engines_1.getEnginesPath(), get_platform_1.getNapiName(this.platform, 'fs'));
            return { enginePath, searchedLocations };
        }
        const searchLocations = [
            eval(`require('path').join(__dirname, '../../../.prisma/client')`),
            (_d = (_c = (_b = this.config.generator) === null || _b === void 0 ? void 0 : _b.output) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : eval('__dirname'),
            path_1.default.join(eval('__dirname'), '..'),
            path_1.default.dirname(this.config.datamodelPath),
            this.config.cwd,
            '/tmp/prisma-engines',
        ];
        if (this.config.dirname) {
            searchLocations.push(this.config.dirname);
        }
        for (const location of searchLocations) {
            searchedLocations.push(location);
            debug(`Search for Query Engine Library in ${location}`);
            enginePath = path_1.default.join(location, get_platform_1.getNapiName(this.platform, 'fs'));
            if (fs_1.default.existsSync(enginePath)) {
                return { enginePath, searchedLocations };
            }
        }
        enginePath = path_1.default.join(__dirname, get_platform_1.getNapiName(this.platform, 'fs'));
        return { enginePath: enginePath !== null && enginePath !== void 0 ? enginePath : '', searchedLocations };
    }
    async getLibQueryEnginePath() {
        var _a, _b, _c, _d;
        const libPath = (_a = process.env.PRISMA_QUERY_ENGINE_LIBRARY) !== null && _a !== void 0 ? _a : this.config.prismaPath;
        if (libPath && fs_1.default.existsSync(libPath)) {
            return libPath;
        }
        this.platform = (_b = this.platform) !== null && _b !== void 0 ? _b : (await get_platform_1.getPlatform());
        const { enginePath, searchedLocations } = await this.resolveEnginePath();
        // If path to query engine doesn't exist, throw
        if (!fs_1.default.existsSync(enginePath)) {
            const pinnedStr = this.platform
                ? `\nYou incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.platform}`)}\n`
                : '';
            let errorText = `Query engine library for current platform "${chalk_1.default.bold(this.platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(enginePath)}")

Searched Locations:

${searchedLocations
                .map((f) => {
                let msg = `  ${f}`;
                if (process.env.DEBUG === 'node-engine-search-locations' &&
                    fs_1.default.existsSync(f)) {
                    const dir = fs_1.default.readdirSync(f);
                    msg += dir.map((d) => `    ${d}`).join('\n');
                }
                return msg;
            })
                .join('\n' + (process.env.DEBUG === 'node-engine-search-locations' ? '\n' : ''))}\n`;
            // The generator should always be there during normal usage
            if (this.config.generator) {
                // The user already added it, but it still doesn't work 🤷‍♀️
                // That means, that some build system just deleted the files 🤔
                this.platform = (_c = this.platform) !== null && _c !== void 0 ? _c : (await get_platform_1.getPlatform());
                if (this.config.generator.binaryTargets.includes(this.platform) ||
                    this.config.generator.binaryTargets.includes('native')) {
                    errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? 's' : ''} ${this.config.generator.binaryTargets
                        .map((t) => `"${chalk_1.default.bold(t)}"`)
                        .join(', ')} to the "${chalk_1.default.underline('generator')}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
                    errorText += ``;
                }
                else {
                    // If they didn't even have the current running platform in the schema.prisma file, it's easy
                    // Just add it
                    errorText += `\n\nTo solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline('binaryTargets')}" attribute in the "${chalk_1.default.underline('generator')}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright('prisma generate')}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
                }
            }
            else {
                errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;
            }
            throw new errors_1.PrismaClientInitializationError(errorText, this.config.clientVersion);
        }
        this.platform = (_d = this.platform) !== null && _d !== void 0 ? _d : (await get_platform_1.getPlatform());
        return enginePath;
    }
    getFixedGenerator() {
        const fixedGenerator = {
            ...this.config.generator,
            binaryTargets: util_1.fixBinaryTargets(this.config.generator.binaryTargets, this.platform),
        };
        return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
}
exports.NAPIEngine = NAPIEngine;
//# sourceMappingURL=NAPIEngine.js.map