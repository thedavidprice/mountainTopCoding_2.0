"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.prettify = exports.prettierConfig = exports.transformTSToJS = exports.typeScriptSourceFiles = exports.convertTsProjectToJs = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _core = require("@babel/core");

var _glob = _interopRequireDefault(require("glob"));

var _prettier = require("prettier");

var _paths = require("./paths");

/**
 * Converts all the TypeScript files in the `api` and `web` sides to JavaScript.
 *
 * @param {string} cwd - The base path to the project.
 */
const convertTsProjectToJs = (cwd = (0, _paths.getPaths)().base) => {
  const files = typeScriptSourceFiles(cwd);

  for (const f of files) {
    const code = transformTSToJS(f);

    if (code) {
      _fs.default.writeFileSync(_path.default.join(cwd, f.replace('.tsx', '.js').replace('.ts', '.js')), code, 'utf8');

      _fs.default.unlinkSync(_path.default.join(cwd, f));
    }
  }

  try {
    _fs.default.renameSync(_path.default.join(cwd, 'api/tsconfig.json'), _path.default.join(cwd, 'api/jsconfig.json'));

    _fs.default.renameSync(_path.default.join(cwd, 'web/tsconfig.json'), _path.default.join(cwd, 'web/jsconfig.json'));
  } catch (e) {
    // I want the user to be able to run this command multiple times.
    console.error(e);
  }
};
/**
 * Get all the source code from a Redwood project
 */


exports.convertTsProjectToJs = convertTsProjectToJs;

const typeScriptSourceFiles = cwd => {
  // TODO: When sides are expanded read the `api` and `web` string instead
  // of hard-coding them.
  return _glob.default.sync('{api,web}/src/**/*.{ts,tsx}', {
    cwd
  });
};
/**
 * Read the contents of a TypeScript file, transpile it to JavaScript,
 * but leave the JSX intact and format via Prettier.
 *
 * @param {string} file - The path to the TypeScript file.
 */


exports.typeScriptSourceFiles = typeScriptSourceFiles;

const transformTSToJS = file => {
  const tsCode = _fs.default.readFileSync(file, 'utf8');

  const filename = _path.default.basename(file);

  const result = (0, _core.transform)(tsCode, {
    filename,
    cwd: (0, _paths.getPaths)().base,
    configFile: false,
    plugins: [['@babel/plugin-transform-typescript', {
      isTSX: true,
      allExtensions: true
    }]],
    retainLines: true
  });

  if (!(result !== null && result !== void 0 && result.code)) {
    return undefined;
  }

  return prettify(result.code, filename.replace(/\.ts$/, '.js'));
};

exports.transformTSToJS = transformTSToJS;

const prettierConfig = () => {
  try {
    return require(_path.default.join((0, _paths.getPaths)().base, 'prettier.config.js'));
  } catch (e) {
    return undefined;
  }
};
/**
 * Determine the prettier parser based off of the extension.
 *
 * See: https://prettier.io/docs/en/options.html#parser
 * @param {string} filename
 */


exports.prettierConfig = prettierConfig;

const prettierParser = filename => {
  switch (_path.default.extname(filename.replace('.template', ''))) {
    case '.css':
      return 'css';

    case '.js':
      return 'babel';

    case '.ts':
    case '.tsx':
      return 'babel-ts';

    default:
      return undefined;
  }
};
/**
 * Prettify `code` according to the extension in `filename`.
 * This will also read a user's `prettier.config.js` file if it exists.
 *
 * @param {string} code
 * @param {string} filename
 */


const prettify = (code, filename) => {
  const parser = prettierParser(filename); // Return unformatted code if we could not determine the parser.

  if (typeof parser === 'undefined') {
    return code;
  }

  return (0, _prettier.format)(code, { ...prettierConfig(),
    parser
  });
};

exports.prettify = prettify;