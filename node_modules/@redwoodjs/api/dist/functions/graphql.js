"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.createGraphQLHandler = exports.createContextHandler = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/map"));

var _interopRequireWildcard2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/interopRequireWildcard"));

var _apolloServerLambda = require("apollo-server-lambda");

var _auth = require("../auth");

var _globalContext = require("../globalContext");

/**
 * We use Apollo Server's `context` option as an entry point to construct our
 * own global context.
 *
 * Context explained by Apollo's Docs:
 * Context is an object shared by all resolvers in a particular query,
 * and is used to contain per-request state, including authentication information,
 * dataloader instances, and anything else that should be taken into account when
 * resolving the query.
 */
const createContextHandler = (userContext, getCurrentUser) => {
  return async ({
    event,
    context
  }) => {
    // Prevent the Serverless function from waiting for all resources (db connections)
    // to be released before returning a reponse.
    context.callbackWaitsForEmptyEventLoop = false; // If the request contains authorization headers, we'll decode the providers that we support,
    // and pass those to the `currentUser`.

    const authContext = await (0, _auth.getAuthenticationContext)({
      event,
      context
    });

    if (authContext) {
      context.currentUser = getCurrentUser ? await getCurrentUser(authContext[0], authContext[1], authContext[2]) : authContext;
    }

    let customUserContext = userContext;

    if (typeof userContext === 'function') {
      // if userContext is a function, run that and return just the result
      customUserContext = await userContext({
        event,
        context
      });
    } // Sets the **global** context object, which can be imported with:
    // import { context } from '@redwoodjs/api'


    return (0, _globalContext.setContext)({ ...context,
      ...customUserContext
    });
  };
};

exports.createContextHandler = createContextHandler;

/**
 * Creates an Apollo GraphQL Server.
 *
 * ```js
 * export const handler = createGraphQLHandler({ schema, context, getCurrentUser })
 * ```
 */
const createGraphQLHandler = ({
  context,
  getCurrentUser,
  onException,
  cors,
  onHealthCheck,
  ...options
} = {}) => {
  const isDevEnv = process.env.NODE_ENV === 'development';
  const handler = new _apolloServerLambda.ApolloServer({
    // Turn off playground, introspection and debug in production.
    debug: isDevEnv,
    introspection: isDevEnv,
    playground: isDevEnv,
    // Log the errors in the console
    formatError: error => {
      if (isDevEnv) {
        // I want the dev-server to pick this up!?
        // TODO: Move the error handling into a separate package
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        _promise.default.resolve().then(() => (0, _interopRequireWildcard2.default)(require('@redwoodjs/dev-server/dist/error'))).then(({
          handleError
        }) => {
          return handleError(error.originalError);
        }).then(console.log).catch(() => {});
      }

      return error;
    },
    // Wrap the user's context function in our own
    context: createContextHandler(context, getCurrentUser),
    ...options
  }).createHandler({
    cors,
    onHealthCheck
  });
  return (event, context, callback) => {
    if ((0, _globalContext.usePerRequestContext)()) {
      // This must be used when you're self-hosting RedwoodJS.
      const localAsyncStorage = (0, _globalContext.getPerRequestContext)();
      localAsyncStorage.run(new _map.default(), () => {
        try {
          handler(event, context, callback);
        } catch (e) {
          onException && onException();
          throw e;
        }
      });
    } else {
      // This is OK for AWS (Netlify/Vercel) because each Lambda request
      // is handled individually.
      try {
        handler(event, context, callback);
      } catch (e) {
        onException && onException();
        throw e;
      }
    }
  };
};

exports.createGraphQLHandler = createGraphQLHandler;