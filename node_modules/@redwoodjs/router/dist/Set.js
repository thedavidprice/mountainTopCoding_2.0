"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.Set = Set;
exports.Private = Private;

var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _reduceRight = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce-right"));

var _react = _interopRequireWildcard(require("react"));

var _links = require("./links");

var _location = require("./location");

var _router = require("./router");

var _routerContext = require("./router-context");

var _util = require("./util");

const IdentityWrapper = ({
  children
}) => {
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children);
};

function Set(props) {
  var _context;

  const {
    wrap,
    children,
    private: privateSet,
    unauthenticated,
    role,
    ...rest
  } = props;
  const routerState = (0, _routerContext.useRouterState)();
  const location = (0, _location.useLocation)();
  const {
    loading,
    isAuthenticated,
    hasRole
  } = routerState.useAuth();

  if (privateSet && !unauthenticated) {
    throw new Error('Private Sets need to specify what route to redirect unauthorized users to by setting the `unauthenticated` prop');
  }

  const unauthorized = (0, _react.useCallback)(() => {
    return !(isAuthenticated && (!role || hasRole(role)));
  }, [isAuthenticated, role, hasRole]); // Make sure `wrappers` is always an array with at least one wrapper component

  const wrappers = (0, _isArray.default)(wrap) ? wrap : [wrap ? wrap : IdentityWrapper];
  const flatChildArray = (0, _util.flattenAll)(children);
  const routes = (0, _filter.default)(_context = (0, _filter.default)(flatChildArray).call(flatChildArray, _router.isRoute)).call(_context, r => typeof r.props.path !== 'undefined');

  for (const route of routes) {
    const path = route.props.path;
    const {
      match
    } = (0, _util.matchPath)(path, location.pathname, routerState.paramTypes);

    if (!match) {
      continue;
    }

    if (privateSet && unauthorized()) {
      if (loading) {
        var _route$props, _route$props$whileLoa;

        return ((_route$props = route.props) === null || _route$props === void 0 ? void 0 : (_route$props$whileLoa = _route$props.whileLoading) === null || _route$props$whileLoa === void 0 ? void 0 : _route$props$whileLoa.call(_route$props)) || null;
      } else {
        var _routerState$routes$f, _context2;

        const currentLocation = global.location.pathname + encodeURIComponent(global.location.search);
        const unauthenticatedPath = (_routerState$routes$f = (0, _filter.default)(_context2 = routerState.routes).call(_context2, ({
          name
        }) => unauthenticated === name)[0]) === null || _routerState$routes$f === void 0 ? void 0 : _routerState$routes$f.path;

        if (!unauthenticatedPath) {
          throw new Error(`We could not find a route named ${unauthenticated}`);
        }

        return /*#__PURE__*/_react.default.createElement(_links.Redirect, {
          to: `${unauthenticatedPath}?redirectTo=${currentLocation}`
        });
      }
    } // Expand and nest the wrapped elements.


    return (0, _reduceRight.default)(wrappers).call(wrappers, (acc, wrapper) => {
      return /*#__PURE__*/_react.default.createElement(wrapper, { ...rest,
        children: acc ? acc : children
      });
    }, undefined) || null;
  } // No match, no render.


  return null;
}

function Private(props) {
  const {
    children,
    unauthenticated,
    role,
    wrap,
    ...rest
  } = props;
  return (
    /*#__PURE__*/
    // @MARK Doesn't matter that we pass `any` here
    // Because user's still get a typed Private component
    // If we leave `<any>` out, TS will infer the generic argument to be
    // `WrapperProps`, which looks more correct, but it will cause a type
    // error I'm not sure how to solve
    _react.default.createElement(Set, (0, _extends2.default)({
      private: true,
      unauthenticated: unauthenticated,
      role: role,
      wrap: wrap
    }, rest), children)
  );
}