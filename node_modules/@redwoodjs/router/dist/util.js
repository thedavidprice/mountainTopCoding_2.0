"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.isReactElement = isReactElement;
exports.flattenAll = flattenAll;
exports.getAnnouncement = exports.replaceParams = exports.validatePath = exports.parseSearch = exports.matchPath = exports.createNamedContext = void 0;

var _matchAll = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/match-all"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _urlSearchParams = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/url-search-params"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/keys"));

var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _keys2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _flatMap = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/flat-map"));

var _react = _interopRequireWildcard(require("react"));

/** Create a React Context with the given name. */
const createNamedContext = (name, defaultValue) => {
  const Ctx = /*#__PURE__*/_react.default.createContext(defaultValue);

  Ctx.displayName = name;
  return Ctx;
};
/**
 * Get param name and type transform for a route
 *
 *  '/blog/{year}/{month}/{day:Int}' => [['year'], ['month'], ['day', 'Int']]
 */


exports.createNamedContext = createNamedContext;

const paramsForRoute = route => {
  var _context;

  // Match the strings between `{` and `}`.
  const params = [...(0, _matchAll.default)(route).call(route, /\{([^}]+)\}/g)];
  return (0, _map.default)(_context = (0, _map.default)(params).call(params, match => match[1])).call(_context, match => {
    return match.split(':');
  });
};

/** Definitions of the core param types. */
const coreParamTypes = {
  Int: {
    constraint: /\d+/,
    transform: Number
  },
  Float: {
    constraint: /[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?/,
    transform: Number
  },
  Boolean: {
    constraint: /true|false/,
    transform: boolAsString => boolAsString === 'true'
  }
};

/**
 * Determine if the given route is a match for the given pathname. If so,
 * extract any named params and return them in an object.
 *
 * route         - The route path as specified in the <Route path={...} />
 * pathname      - The pathname from the window.location.
 * allParamTypes - The object containing all param type definitions.
 *
 * Examples:
 *
 *  matchPath('/blog/{year}/{month}/{day}', '/blog/2019/12/07')
 *  => { match: true, params: { year: '2019', month: '12', day: '07' }}
 *
 *  matchPath('/about', '/')
 *  => { match: false }
 *
 *  matchPath('/post/{id:Int}', '/post/7')
 *  => { match: true, params: { id: 7 }}
 */
const matchPath = (route, pathname, paramTypes) => {
  var _context2;

  // Get the names and the transform types for the given route.
  const routeParams = paramsForRoute(route);
  const allParamTypes = { ...coreParamTypes,
    ...paramTypes
  };
  let typeConstrainedRoute = route; // Map all params from the route to their type constraint regex to create a "type-constrained route" regexp

  for (const [name, type] of routeParams) {
    var _allParamTypes;

    let typeRegex = '[^/]+'; // Undefined constraint if not supported
    // So leaves it as string

    const constraint = type && ((_allParamTypes = allParamTypes[type]) === null || _allParamTypes === void 0 ? void 0 : _allParamTypes.constraint);

    if (constraint) {
      // Get the regex as a string
      typeRegex = constraint.source || '[^/]+';
    }

    typeConstrainedRoute = typeConstrainedRoute.replace(type ? `{${name}:${type}}` : `{${name}}`, `(${typeRegex})`);
  } // Does the `pathname` match the route?


  const matches = [...(0, _matchAll.default)(pathname).call(pathname, new RegExp(`^${typeConstrainedRoute}$`, 'g'))];

  if (matches.length === 0) {
    return {
      match: false
    };
  } // Map extracted values to their param name, casting the value if needed


  const providedParams = (0, _slice.default)(_context2 = matches[0]).call(_context2, 1);
  const params = (0, _reduce.default)(providedParams).call(providedParams, (acc, value, index) => {
    const [name, transformName] = routeParams[index];
    const typeInfo = allParamTypes[transformName];
    let transformedValue = value;

    if (typeInfo && typeof typeInfo.transform === 'function') {
      transformedValue = typeInfo.transform(value);
    }

    return { ...acc,
      [name]: transformedValue
    };
  }, {});
  return {
    match: true,
    params
  };
};
/**
 * Parse the given search string into key/value pairs and return them in an
 * object.
 *
 * Examples:
 *
 *  parseSearch('?key1=val1&key2=val2')
 *  => { key1: 'val1', key2: 'val2' }
 *
 * @fixme
 * This utility ignores keys with multiple values such as `?foo=1&foo=2`.
 */


exports.matchPath = matchPath;

const parseSearch = search => {
  var _context3;

  const searchParams = new _urlSearchParams.default(search);
  return (0, _reduce.default)(_context3 = [...(0, _keys.default)(searchParams).call(searchParams)]).call(_context3, (params, key) => ({ ...params,
    [key]: searchParams.get(key)
  }), {});
};
/**
 * Validate a path to make sure it follows the router's rules. If any problems
 * are found, a descriptive Error will be thrown, as problems with routes are
 * critical enough to be considered fatal.
 */


exports.parseSearch = parseSearch;

const validatePath = path => {
  // Check that path begins with a slash.
  if (!(0, _startsWith.default)(path).call(path, '/')) {
    throw new Error(`Route path does not begin with a slash: "${path}"`);
  }

  if ((0, _indexOf.default)(path).call(path, ' ') >= 0) {
    throw new Error(`Route path contains spaces: "${path}"`);
  } // Check for duplicate named params.


  const matches = (0, _matchAll.default)(path).call(path, /\{([^}]+)\}/g);
  const memo = {};

  for (const match of matches) {
    // Extract the param's name to make sure there aren't any duplicates
    const param = match[1].split(':')[0];

    if (memo[param]) {
      throw new Error(`Route path contains duplicate parameter: "${path}"`);
    } else {
      memo[param] = true;
    }
  }
};
/**
 * Take a given route path and replace any named parameters with those in the
 * given args object. Any extra params not used in the path will be appended
 * as key=value pairs in the search part.
 *
 * Examples:
 *
 *   replaceParams('/tags/{tag}', { tag: 'code', extra: 'foo' })
 *   => '/tags/code?extra=foo
 */


exports.validatePath = validatePath;

const replaceParams = (path, args = {}) => {
  var _context4;

  // Split the path apart and replace named parameters with those sent in,
  // then join it back together.
  const parts = path.split('/');
  let newPath = (0, _map.default)(parts).call(parts, part => {
    if (part[0] === '{' && part[part.length - 1] === '}') {
      const paramSpec = part.substr(1, part.length - 2);
      const paramName = paramSpec.split(':')[0];
      const arg = args[paramName];

      if (arg) {
        delete args[paramName];
        return arg;
      }
    }

    return part;
  }).join('/'); // Prepare any unnamed params to be be appended as search params.

  const queryParams = [];
  (0, _forEach.default)(_context4 = (0, _keys2.default)(args)).call(_context4, key => {
    queryParams.push(`${key}=${args[key]}`);
  }); // Append any unnamed params as search params.

  if (queryParams.length) {
    newPath += `?${queryParams.join('&')}`;
  }

  return newPath;
};

exports.replaceParams = replaceParams;

function isReactElement(node) {
  return node !== undefined && node !== null && node.type !== undefined;
}

function flattenAll(children) {
  const childrenArray = _react.Children.toArray(children);

  return (0, _flatMap.default)(childrenArray).call(childrenArray, child => {
    if (isReactElement(child) && child.props.children) {
      return [child, ...flattenAll(child.props.children)];
    }

    return [child];
  });
}

/**
 * gets the announcement for the new page.
 * called in page-loader's `componentDidUpdate`.
 *
 * the order of priority is:
 * 1. RouteAnnouncement (the most specific one)
 * 2. h1
 * 3. document.title
 * 4. location.pathname
 */
const getAnnouncement = () => {
  var _global, _global$document$quer, _global2, _global3, _global4;

  const routeAnnouncement = (_global = global) === null || _global === void 0 ? void 0 : (_global$document$quer = _global.document.querySelectorAll('[data-redwood-route-announcement]')) === null || _global$document$quer === void 0 ? void 0 : _global$document$quer[0];

  if (routeAnnouncement !== null && routeAnnouncement !== void 0 && routeAnnouncement.textContent) {
    return routeAnnouncement.textContent;
  }

  const pageHeading = (_global2 = global) === null || _global2 === void 0 ? void 0 : _global2.document.querySelector(`h1`);

  if (pageHeading !== null && pageHeading !== void 0 && pageHeading.textContent) {
    return pageHeading.textContent;
  }

  if ((_global3 = global) !== null && _global3 !== void 0 && _global3.document.title) {
    return document.title;
  }

  return `new page at ${(_global4 = global) === null || _global4 === void 0 ? void 0 : _global4.location.pathname}`;
};

exports.getAnnouncement = getAnnouncement;