"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.isRoute = isRoute;
exports.routes = exports.Private = exports.Route = exports.Router = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _react = _interopRequireDefault(require("react"));

var _internal = require("./internal");

var _params = require("./params");

var _privateContext = require("./private-context");

var _RouteNameContext = require("./RouteNameContext");

var _routerContext = require("./router-context");

var _splashPage = require("./splash-page");

var _util = require("./util");

// The guts of the router implementation.
// namedRoutes is populated at run-time by iterating over the `<Route />`
// components, and appending them to this object.
const namedRoutes = {};
exports.routes = namedRoutes;

const Route = props => {
  return /*#__PURE__*/_react.default.createElement(InternalRoute, props);
};

exports.Route = Route;

const InternalRoute = ({
  path,
  page,
  name,
  redirect,
  notfound,
  whileLoading = () => null
}) => {
  const location = (0, _internal.useLocation)();
  const routerState = (0, _routerContext.useRouterState)();
  const {
    routeName
  } = (0, _RouteNameContext.useRouteName)();
  const {
    isPrivate,
    unauthorized,
    unauthenticated
  } = (0, _privateContext.usePrivate)();
  const {
    loading
  } = routerState.useAuth();

  if (notfound) {
    // The "notfound" route is handled by <NotFoundChecker>
    return null;
  }

  if (!path) {
    throw new Error(`Route "${name}" needs to specify a path`);
  } // Check for issues with the path.


  (0, _internal.validatePath)(path);
  const {
    match,
    params: pathParams
  } = (0, _internal.matchPath)(path, location.pathname, routerState.paramTypes);

  if (!match) {
    return null;
  }

  if (isPrivate) {
    if (loading) {
      return whileLoading();
    }

    if (unauthorized()) {
      const currentLocation = global.location.pathname + encodeURIComponent(global.location.search);
      return /*#__PURE__*/_react.default.createElement(_internal.Redirect, {
        to: `${namedRoutes[unauthenticated]()}?redirectTo=${currentLocation}`
      });
    }
  }

  const searchParams = (0, _internal.parseSearch)(location.search);
  const allParams = { ...pathParams,
    ...searchParams
  };

  if (redirect) {
    const newPath = (0, _internal.replaceParams)(redirect, allParams);
    return /*#__PURE__*/_react.default.createElement(_internal.Redirect, {
      to: newPath
    });
  }

  if (!page || !name) {
    throw new Error("A route that's not a redirect or notfound route needs to specify both a `page` and a `name`");
  }

  if (name !== routeName) {
    // This guards against rendering two pages when the current URL matches two paths
    //   <Route path="/about" page={AboutPage} name="about" />
    //   <Route path="/{param}" page={ParamPage} name="param" />
    // If we go to /about, only the page with name "about" should be rendered
    return null;
  }

  return /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(page),
    delay: routerState.pageLoadingDelay,
    params: allParams
  });
};

/**
 * `Routes` nested in `Private` require authentication.
 * When a user is not authenticated and attempts to visit this route they will be
 * redirected to `unauthenticated` route.
 */
const Private = ({
  children,
  unauthenticated,
  role
}) => {
  return /*#__PURE__*/_react.default.createElement(_privateContext.PrivateContextProvider, {
    isPrivate: true,
    role: role,
    unauthenticated: unauthenticated
  }, children);
};

exports.Private = Private;

function isRoute(node) {
  return (0, _util.isReactElement)(node) && node.type === Route;
}

const Router = ({
  useAuth,
  paramTypes,
  pageLoadingDelay,
  children
}) => {
  const flatChildArray = (0, _util.flattenAll)(children);
  const shouldShowSplash = flatChildArray.length === 1 && isRoute(flatChildArray[0]) && flatChildArray[0].props.notfound;

  if (shouldShowSplash) {
    return /*#__PURE__*/_react.default.createElement(_splashPage.SplashPage, null);
  }

  (0, _forEach.default)(flatChildArray).call(flatChildArray, child => {
    if (isRoute(child)) {
      const {
        name,
        path
      } = child.props;

      if (path) {
        // Check for issues with the path.
        (0, _internal.validatePath)(path);

        if (name && path) {
          namedRoutes[name] = (args = {}) => (0, _internal.replaceParams)(path, args);
        }
      }
    }
  });
  return /*#__PURE__*/_react.default.createElement(_routerContext.RouterContextProvider, {
    useAuth: useAuth,
    paramTypes: paramTypes,
    pageLoadingDelay: pageLoadingDelay
  }, /*#__PURE__*/_react.default.createElement(_internal.LocationProvider, null, /*#__PURE__*/_react.default.createElement(_params.ParamsProvider, null, /*#__PURE__*/_react.default.createElement(RouteScanner, null, children))));
};

exports.Router = Router;

const RouteScanner = ({
  children
}) => {
  const location = (0, _internal.useLocation)();
  const routerState = (0, _routerContext.useRouterState)();
  let foundMatchingRoute = false;
  let routeName = undefined;
  let NotFoundPage = undefined;
  const flatChildArray = (0, _util.flattenAll)(children);

  for (const child of flatChildArray) {
    if (isRoute(child)) {
      const {
        path,
        name
      } = child.props;

      if (path) {
        const {
          match
        } = (0, _internal.matchPath)(path, location.pathname, routerState.paramTypes);

        if (match) {
          routeName = name; // name is undefined for redirect routes

          foundMatchingRoute = true; // No need to loop further. As soon as we have a matching route and a
          // route name we have all the info we need

          break;
        }
      }

      if (child.props.notfound && child.props.page) {
        NotFoundPage = child.props.page;
      }
    }
  }

  return /*#__PURE__*/_react.default.createElement(_RouteNameContext.RouteNameProvider, {
    value: {
      routeName
    }
  }, !foundMatchingRoute && NotFoundPage ? /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(NotFoundPage),
    delay: routerState.pageLoadingDelay
  }) : children);
};

function isSpec(specOrPage) {
  return specOrPage.loader !== undefined;
}

/**
 * Pages can be imported automatically or manually. Automatic imports are actually
 * objects and take the following form (which we call a 'spec'):
 *
 *   const WhateverPage = {
 *     name: 'WhateverPage',
 *     loader: () => import('src/pages/WhateverPage')
 *   }
 *
 * Manual imports simply load the page:
 *
 *   import WhateverPage from 'src/pages/WhateverPage'
 *
 * Before passing a "page" to the PageLoader, we will normalize the manually
 * imported version into a spec.
 */
const normalizePage = specOrPage => {
  if (isSpec(specOrPage)) {
    // Already a spec, just return it.
    return specOrPage;
  } // Wrap the Page in a fresh spec, and put it in a promise to emulate
  // an async module import.


  return {
    name: specOrPage.name,
    loader: async () => ({
      default: specOrPage
    })
  };
};