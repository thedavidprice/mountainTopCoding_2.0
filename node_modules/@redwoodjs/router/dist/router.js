"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.Route = Route;
exports.isRoute = isRoute;
exports.routes = exports.Router = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _react = _interopRequireDefault(require("react"));

var _internal = require("./internal");

var _params = require("./params");

var _routerContext = require("./router-context");

var _splashPage = require("./splash-page");

var _util = require("./util");

// The guts of the router implementation.
// namedRoutes is populated at run-time by iterating over the `<Route />`
// components, and appending them to this object.
const namedRoutes = {};
exports.routes = namedRoutes;

function Route(props) {
  return /*#__PURE__*/_react.default.createElement(InternalRoute, props);
}

const InternalRoute = ({
  path,
  page,
  name,
  redirect,
  notfound,
  whileLoadingPage
}) => {
  const location = (0, _internal.useLocation)();
  const routerState = (0, _routerContext.useRouterState)();

  if (notfound) {
    // The "notfound" route is handled by <NotFoundChecker>
    return null;
  }

  if (!path) {
    throw new Error(`Route "${name}" needs to specify a path`);
  } // Check for issues with the path.


  (0, _internal.validatePath)(path);
  const {
    match,
    params: pathParams
  } = (0, _internal.matchPath)(path, location.pathname, routerState.paramTypes);

  if (!match) {
    return null;
  }

  const searchParams = (0, _internal.parseSearch)(location.search);
  const allParams = { ...pathParams,
    ...searchParams
  };

  if (redirect) {
    const newPath = (0, _internal.replaceParams)(redirect, allParams);
    return /*#__PURE__*/_react.default.createElement(_internal.Redirect, {
      to: newPath
    });
  }

  if (!page || !name) {
    throw new Error("A route that's not a redirect or notfound route needs to specify both a `page` and a `name`");
  }

  return /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(page),
    delay: routerState.pageLoadingDelay,
    params: allParams,
    whileLoadingPage: whileLoadingPage
  });
};

function isRoute(node) {
  return (0, _util.isReactElement)(node) && node.type === Route;
}

const Router = ({
  useAuth,
  paramTypes,
  pageLoadingDelay,
  children
}) => /*#__PURE__*/_react.default.createElement(_internal.LocationProvider, null, /*#__PURE__*/_react.default.createElement(LocationAwareRouter, {
  useAuth: useAuth,
  paramTypes: paramTypes,
  pageLoadingDelay: pageLoadingDelay
}, children));

exports.Router = Router;

const LocationAwareRouter = ({
  useAuth,
  paramTypes,
  pageLoadingDelay,
  children
}) => {
  var _activeRoute, _activeRoute$props;

  const {
    pathname
  } = (0, _internal.useLocation)();
  const flatChildArray = (0, _util.flattenAll)(children);
  const shouldShowSplash = flatChildArray.length === 1 && isRoute(flatChildArray[0]) && flatChildArray[0].props.notfound;

  if (shouldShowSplash) {
    return /*#__PURE__*/_react.default.createElement(_splashPage.SplashPage, null);
  }

  (0, _forEach.default)(flatChildArray).call(flatChildArray, child => {
    if (isRoute(child)) {
      const {
        name,
        path
      } = child.props;

      if (path) {
        // Check for issues with the path.
        (0, _internal.validatePath)(path);

        if (name && path) {
          namedRoutes[name] = (args = {}) => (0, _internal.replaceParams)(path, args);
        }
      }
    }
  });
  let activeRoute = undefined;
  let NotFoundPage = undefined;
  const activeChildren = activeRouteTree(children, child => {
    if (child.props.path) {
      const {
        match
      } = (0, _internal.matchPath)(child.props.path, pathname, paramTypes);

      if (match) {
        activeRoute = child; // No need to loop further. As soon as we have a matching route we have
        // all the info we need

        return true;
      }
    }

    if (child.props.notfound && child.props.page) {
      NotFoundPage = child.props.page;
    }

    return false;
  });
  return /*#__PURE__*/_react.default.createElement(_routerContext.RouterContextProvider, {
    useAuth: useAuth,
    paramTypes: paramTypes,
    pageLoadingDelay: pageLoadingDelay
  }, /*#__PURE__*/_react.default.createElement(_params.ParamsProvider, {
    path: (_activeRoute = activeRoute) === null || _activeRoute === void 0 ? void 0 : (_activeRoute$props = _activeRoute.props) === null || _activeRoute$props === void 0 ? void 0 : _activeRoute$props.path
  }, !activeRoute && NotFoundPage ? /*#__PURE__*/_react.default.createElement(_internal.PageLoader, {
    spec: normalizePage(NotFoundPage),
    delay: pageLoadingDelay
  }) : activeRoute && activeChildren));
};
/*
 * Find the active (i.e. first matching) route and discard any other routes.
 * Also, keep any <Set>s wrapping the active route.
 */


function activeRouteTree(children, isActive) {
  var _context;

  let active = false;
  return (0, _reduce.default)(_context = _react.default.Children.toArray(children)).call(_context, (acc, child) => {
    if (active) {
      return acc;
    }

    if (isRoute(child)) {
      // We have a <Route ...> element, let's check if it's the one we should
      // render (i.e. the active route)
      active = isActive(child);

      if (active) {
        // Keep this child. It's the last one we'll keep since `active` is `true`
        // now
        acc.push(child);
      }
    } else if ((0, _util.isReactElement)(child) && child.props.children) {
      // We have a child element that's not a <Route ...>, and that has
      // children. It's probably a <Set>. Recurse down one level
      const nestedChildren = activeRouteTree(child.props.children, isActive);

      if (nestedChildren.length > 0) {
        // We found something we wanted to keep. So let's push it to our
        // "active route tree"
        acc.push( /*#__PURE__*/_react.default.cloneElement(child, child.props, nestedChildren));
        active = true;
      }
    }

    return acc;
  }, []);
}

function isSpec(specOrPage) {
  return specOrPage.loader !== undefined;
}

/**
 * Pages can be imported automatically or manually. Automatic imports are actually
 * objects and take the following form (which we call a 'spec'):
 *
 *   const WhateverPage = {
 *     name: 'WhateverPage',
 *     loader: () => import('src/pages/WhateverPage')
 *   }
 *
 * Manual imports simply load the page:
 *
 *   import WhateverPage from 'src/pages/WhateverPage'
 *
 * Before passing a "page" to the PageLoader, we will normalize the manually
 * imported version into a spec.
 */
const normalizePage = specOrPage => {
  if (isSpec(specOrPage)) {
    // Already a spec, just return it.
    return specOrPage;
  } // Wrap the Page in a fresh spec, and put it in a promise to emulate
  // an async module import.


  return {
    name: specOrPage.name,
    loader: async () => ({
      default: specOrPage
    })
  };
};