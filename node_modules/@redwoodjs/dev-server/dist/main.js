#!/usr/bin/env node
"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.getArgsForSide = void 0;

var _yargs = _interopRequireDefault(require("yargs"));

var _internal = require("@redwoodjs/internal");

var _error = require("./error");

var _http = require("./http");

var _awsLambdaApolloServer = require("./requestHandlers/awsLambdaApolloServer");

var _awsLambdaEnvelop = require("./requestHandlers/awsLambdaEnvelop");

var _watchApiSide = require("./watchApiSide");

// TODO: Expand the sides once that concept is introduced.
const getArgsForSide = side => {
  const config = (0, _internal.getConfig)();
  const {
    port,
    host
  } = config[side];
  const useEnvelop = config.experimental.useEnvelop;
  const paths = (0, _internal.getPaths)();
  return {
    port,
    host,
    paths: paths[side],
    useEnvelop
  };
};

exports.getArgsForSide = getArgsForSide;

const {
  side
} = _yargs.default.option('side', {
  default: 'api'
}).argv;

try {
  const {
    host,
    port,
    paths,
    useEnvelop
  } = getArgsForSide(side);
  const requestHandler = useEnvelop ? _awsLambdaEnvelop.requestHandlerEnvelop : _awsLambdaApolloServer.requestHandlerApolloServer;
  (0, _http.server)({
    requestHandler
  }).listen(port, () => {
    console.log(`Running at 'http://${host}:${port}'`);

    if (useEnvelop) {
      console.log('Using experimental envelop GraphQL execution layer ');
    }

    console.log(`Watching files in '${paths.functions}'`);
    let startBuild = new Date().getTime();
    (0, _watchApiSide.watchFunctions)({
      paths,
      onChange: () => {
        startBuild = new Date().getTime();
        process.stdout.write('Change detected, building... ');
      },
      onImport: functions => {
        console.log(`Done. Took ${new Date().getTime() - startBuild}ms.`);
        (0, _http.setLambdaFunctions)(functions);
      },
      onException: async e => {
        console.log(await (0, _error.handleError)(e));
      }
    });
  });
} catch (e) {
  (0, _error.handleError)(e).then(m => {
    console.log(m);
    process.exit(1);
  });
}