"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.builder = exports.description = exports.command = exports.files = void 0;

require("core-js/modules/esnext.weak-map.delete-all.js");

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _internal = require("@redwoodjs/internal");

var _lib = require("../../../lib");

var _generate = require("../../generate");

var _helpers = require("../helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const COMPONENT_SUFFIX = 'Cell';
const REDWOOD_WEB_PATH_NAME = 'components';

const getCellOperationNames = async () => {
  const {
    getProject
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('@redwoodjs/structure')));
  return getProject().cells.map(x => {
    return x.queryOperationName;
  }).filter(Boolean);
};

const uniqueOperationName = async (name, {
  index = 1,
  list = false
}) => {
  let operationName = (0, _pascalcase.default)(index <= 1 ? `find_${name}_query` : `find_${name}_query_${index}`);

  if (list) {
    operationName = index <= 1 ? `${(0, _pascalcase.default)(name)}Query` : `${(0, _pascalcase.default)(name)}Query_${index}`;
  }

  const cellOperationNames = await getCellOperationNames();

  if (!cellOperationNames.includes(operationName)) {
    return operationName;
  }

  return uniqueOperationName(name, {
    index: index + 1
  });
};

const getIdType = model => {
  var _model$fields$find;

  return (_model$fields$find = model.fields.find(field => field.isId)) === null || _model$fields$find === void 0 ? void 0 : _model$fields$find.type;
};

const files = async ({
  name,
  typescript: generateTypescript,
  ...options
}) => {
  let cellName = name;
  let idType,
      model = null;
  let templateNameSuffix = ''; // Create a unique operation name.

  const shouldGenerateList = ((0, _helpers.isWordNonPluralizable)(name) ? options.list : _pluralize.default.isPlural(name)) || options.list;

  if (shouldGenerateList) {
    cellName = (0, _helpers.forcePluralizeWord)(name);
    templateNameSuffix = 'List'; // override operationName so that its find_operationName
  } else {
    // needed for the singular cell GQL query find by id case
    try {
      model = await (0, _lib.getSchema)((0, _pascalcase.default)(_pluralize.default.singular(name)));
      idType = getIdType(model);
    } catch {
      // eat error so that the destroy cell generator doesn't raise when try to find prisma query engine in test runs
      // assume id will be Int, otherwise generated will keep throwing
      idType = 'Int';
    }
  }

  const operationName = await uniqueOperationName(cellName, {
    list: shouldGenerateList
  });
  const cellFile = (0, _helpers.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: generateTypescript ? '.tsx' : '.js',
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: 'cell',
    templatePath: `cell${templateNameSuffix}.tsx.template`,
    templateVars: {
      operationName,
      idType
    }
  });
  const testFile = (0, _helpers.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: generateTypescript ? '.test.tsx' : '.test.js',
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: 'cell',
    templatePath: 'test.js.template'
  });
  const storiesFile = (0, _helpers.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: generateTypescript ? '.stories.tsx' : '.stories.js',
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: 'cell',
    templatePath: 'stories.js.template'
  });
  const mockFile = (0, _helpers.templateForComponentFile)({
    name: cellName,
    suffix: COMPONENT_SUFFIX,
    extension: generateTypescript ? '.mock.ts' : '.mock.js',
    webPathSection: REDWOOD_WEB_PATH_NAME,
    generator: 'cell',
    templatePath: `mock${templateNameSuffix}.js.template`
  });
  const files = [cellFile];

  if (options.stories) {
    files.push(storiesFile);
  }

  if (options.tests) {
    files.push(testFile);
  }

  if (options.stories || options.tests) {
    files.push(mockFile);
  } // Returns
  // {
  //    "path/to/fileA": "<<<template>>>",
  //    "path/to/fileB": "<<<template>>>",
  // }


  return files.reduce((acc, [outputPath, content]) => {
    const template = generateTypescript ? content : (0, _lib.transformTSToJS)(outputPath, content);
    return {
      [outputPath]: template,
      ...acc
    };
  }, {});
};

exports.files = files;
const {
  command,
  description,
  builder,
  handler
} = (0, _helpers.createYargsForComponentGeneration)({
  componentName: 'cell',
  filesFn: files,
  optionsObj: { ..._generate.yargsDefaults,
    list: {
      alias: 'l',
      default: false,
      description: 'Use when you want to generate a cell for a list of the model name.',
      type: 'boolean'
    }
  },
  includeAdditionalTasks: () => {
    return [{
      title: `Generating types ...`,
      task: async () => {
        return (0, _internal.generate)();
      }
    }];
  }
});
exports.handler = handler;
exports.builder = builder;
exports.description = description;
exports.command = command;