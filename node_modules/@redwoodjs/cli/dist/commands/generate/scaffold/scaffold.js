"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitPathAndModel = exports.handler = exports.builder = exports.description = exports.command = exports.routes = exports.files = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _camelcase = _interopRequireDefault(require("camelcase"));

var _humanizeString = _interopRequireDefault(require("humanize-string"));

var _listr = _interopRequireDefault(require("listr"));

var _paramCase = require("param-case");

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _internal = require("@redwoodjs/internal");

var _lib = require("../../../lib");

var _colors = _interopRequireDefault(require("../../../lib/colors"));

var _generate = require("../../generate");

var _dbAuth = require("../dbAuth/dbAuth");

var _helpers = require("../helpers");

var _sdl = require("../sdl/sdl");

var _service = require("../service/service");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NON_EDITABLE_COLUMNS = ['id', 'createdAt', 'updatedAt']; // Any assets that should not trigger an overwrite error and require a --force

const SKIPPABLE_ASSETS = ['scaffold.css'];
const PACKAGE_SET = 'Set';

const getIdType = model => {
  var _model$fields$find;

  return (_model$fields$find = model.fields.find(field => field.isId)) === null || _model$fields$find === void 0 ? void 0 : _model$fields$find.type;
};

const getImportComponentNames = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  let componentPath;
  let layoutPath;

  if (scaffoldPath === '') {
    componentPath = nestScaffoldByModel ? `src/components/${singularName}` : `src/components`;
    layoutPath = `src/layouts`;
  } else {
    const sP = scaffoldPath.split('/').map(_pascalcase.default).join('/');
    componentPath = nestScaffoldByModel ? `src/components/${sP}/${singularName}` : `src/components/${sP}`;
    layoutPath = `src/layouts/${sP}`;
  }

  return {
    importComponentName: `${componentPath}/${singularName}`,
    importComponentNameCell: `${componentPath}/${singularName}Cell`,
    importComponentEditNameCell: `${componentPath}/Edit${singularName}Cell`,
    importComponentNameForm: `${componentPath}/${singularName}Form`,
    importComponentNewName: `${componentPath}/New${singularName}`,
    importComponentNames: `${componentPath}/${pluralName}`,
    importComponentNamesCell: `${componentPath}/${pluralName}Cell`,
    importLayoutNames: `${layoutPath}/${pluralName}Layout`
  };
}; // Includes imports from getImportComponentNames()


const getTemplateStrings = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const pluralPascalName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularPascalName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const pluralCamelName = (0, _camelcase.default)(pluralPascalName);
  const singularCamelName = (0, _camelcase.default)(singularPascalName);
  const camelScaffoldPath = (0, _camelcase.default)((0, _pascalcase.default)(scaffoldPath));
  return {
    pluralRouteName: scaffoldPath === '' ? pluralCamelName : `${camelScaffoldPath}${pluralPascalName}`,
    editRouteName: scaffoldPath === '' ? `edit${singularPascalName}` : `${camelScaffoldPath}Edit${singularPascalName}`,
    singularRouteName: scaffoldPath === '' ? singularCamelName : `${camelScaffoldPath}${singularPascalName}`,
    newRouteName: scaffoldPath === '' ? `new${singularPascalName}` : `${camelScaffoldPath}New${singularPascalName}`,
    ...getImportComponentNames(name, scaffoldPath, nestScaffoldByModel)
  };
};

const files = async ({
  model: name,
  path: scaffoldPath = '',
  tests = true,
  typescript = false,
  nestScaffoldByModel
}) => {
  const model = await (0, _lib.getSchema)((0, _pascalcase.default)(_pluralize.default.singular(name)));

  if (typeof nestScaffoldByModel === 'undefined') {
    nestScaffoldByModel = (0, _internal.getConfig)().generate.nestScaffoldByModel;
  }

  const templateStrings = getTemplateStrings(name, scaffoldPath, nestScaffoldByModel);
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : scaffoldPath.split('/').map(_pascalcase.default).join('/') + '/';
  return { ...(await componentFiles(name, pascalScaffoldPath, typescript, nestScaffoldByModel, templateStrings, typescript)),
    ...(await (0, _sdl.files)({ ...(0, _lib.getDefaultArgs)(_sdl.builder),
      name,
      crud: true,
      typescript
    })),
    ...(await (0, _service.files)({ ...(0, _lib.getDefaultArgs)(_service.builder),
      name,
      crud: true,
      relations: (0, _helpers.relationsForModel)(model),
      tests,
      typescript
    })),
    ...assetFiles(name),
    ...layoutFiles(name, pascalScaffoldPath, typescript, templateStrings, typescript),
    ...(await pageFiles(name, pascalScaffoldPath, typescript, nestScaffoldByModel, templateStrings, typescript))
  };
};

exports.files = files;

const assetFiles = name => {
  let fileList = {};

  const assets = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'assets'));

  assets.forEach(asset => {
    const outputAssetName = asset.replace(/\.template/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.src, outputAssetName); // skip assets that already exist on disk, never worry about overwriting


    if (!SKIPPABLE_ASSETS.includes(_path.default.basename(outputPath)) || !_fs.default.existsSync(outputPath)) {
      const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'assets', asset), {
        name
      });
      fileList[outputPath] = template;
    }
  });
  return fileList;
};

const layoutFiles = (name, pascalScaffoldPath = '', generateTypescript, templateStrings) => {
  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  let fileList = {};

  const layouts = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'layouts'));

  layouts.forEach(layout => {
    const outputLayoutName = layout.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.js');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.layouts, pascalScaffoldPath, outputLayoutName.replace(/\.(js|tsx?)/, ''), outputLayoutName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'layouts', layout), {
      name,
      pascalScaffoldPath,
      ...templateStrings
    });
    fileList[outputPath] = generateTypescript ? template : (0, _lib.transformTSToJS)(outputPath, template);
  });
  return fileList;
};

const pageFiles = async (name, pascalScaffoldPath = '', generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const model = await (0, _lib.getSchema)(singularName);
  const idType = getIdType(model);
  let fileList = {};

  const pages = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'pages'));

  pages.forEach(page => {
    // Sanitize page names
    const outputPageName = page.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.js');
    const finalFolder = (nestScaffoldByModel ? singularName + '/' : '') + outputPageName.replace(/\.(js|tsx?)/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.pages, pascalScaffoldPath, finalFolder, outputPageName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'pages', page), {
      idType,
      name,
      pascalScaffoldPath,
      ...templateStrings
    });
    fileList[outputPath] = generateTypescript ? template : (0, _lib.transformTSToJS)(outputPath, template);
  });
  return fileList;
};

const componentFiles = async (name, pascalScaffoldPath = '', generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const singularName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const model = await (0, _lib.getSchema)(singularName);
  const idType = getIdType(model);
  const intForeignKeys = (0, _helpers.intForeignKeysForModel)(model);
  let fileList = {};
  const componentMetadata = {
    Boolean: {
      componentName: 'CheckboxField',
      defaultProp: 'defaultChecked',
      validation: false,
      listDisplayFunction: 'checkboxInputTag',
      displayFunction: 'checkboxInputTag'
    },
    DateTime: {
      componentName: 'DatetimeLocalField',
      deserilizeFunction: 'formatDatetime',
      listDisplayFunction: 'timeTag',
      displayFunction: 'timeTag'
    },
    Int: {
      componentName: 'NumberField'
    },
    Json: {
      componentName: 'TextAreaField',
      transformValue: 'Json',
      displayFunction: 'jsonDisplay',
      listDisplayFunction: 'jsonTruncate',
      deserilizeFunction: 'JSON.stringify'
    },
    Float: {
      transformValue: 'Float'
    },
    default: {
      componentName: 'TextField',
      defaultProp: 'defaultValue',
      deserilizeFunction: '',
      validation: '{{ required: true }}',
      displayFunction: undefined,
      listDisplayFunction: 'truncate',
      transformValue: undefined
    }
  };
  const columns = model.fields.filter(field => field.kind !== 'object').map(column => {
    var _componentMetadata$co, _componentMetadata$co2, _componentMetadata$co3, _componentMetadata$co4, _componentMetadata$co5, _componentMetadata$co6, _componentMetadata$co7, _componentMetadata$co8;

    return { ...column,
      label: (0, _humanizeString.default)(column.name),
      component: ((_componentMetadata$co = componentMetadata[column.type]) === null || _componentMetadata$co === void 0 ? void 0 : _componentMetadata$co.componentName) || componentMetadata.default.componentName,
      defaultProp: ((_componentMetadata$co2 = componentMetadata[column.type]) === null || _componentMetadata$co2 === void 0 ? void 0 : _componentMetadata$co2.defaultProp) || componentMetadata.default.defaultProp,
      deserilizeFunction: ((_componentMetadata$co3 = componentMetadata[column.type]) === null || _componentMetadata$co3 === void 0 ? void 0 : _componentMetadata$co3.deserilizeFunction) || componentMetadata.default.deserilizeFunction,
      validation: (_componentMetadata$co4 = (_componentMetadata$co5 = componentMetadata[column.type]) === null || _componentMetadata$co5 === void 0 ? void 0 : _componentMetadata$co5.validation) !== null && _componentMetadata$co4 !== void 0 ? _componentMetadata$co4 : componentMetadata.default.validation,
      listDisplayFunction: ((_componentMetadata$co6 = componentMetadata[column.type]) === null || _componentMetadata$co6 === void 0 ? void 0 : _componentMetadata$co6.listDisplayFunction) || componentMetadata.default.listDisplayFunction,
      displayFunction: ((_componentMetadata$co7 = componentMetadata[column.type]) === null || _componentMetadata$co7 === void 0 ? void 0 : _componentMetadata$co7.displayFunction) || componentMetadata.default.displayFunction,
      transformValue: ((_componentMetadata$co8 = componentMetadata[column.type]) === null || _componentMetadata$co8 === void 0 ? void 0 : _componentMetadata$co8.transformValue) || componentMetadata.default.transformValue
    };
  });
  const editableColumns = columns.filter(column => {
    return NON_EDITABLE_COLUMNS.indexOf(column.name) === -1;
  });
  const fieldsToImport = Object.keys(editableColumns.reduce((accumulator, column) => {
    accumulator[column.component] = true;
    return accumulator;
  }, {}));

  if (!fieldsToImport.length) {
    throw new Error(`There are no editable fields in the ${name} model`);
  }

  const components = _fs.default.readdirSync(_path.default.join(_lib.templateRoot, 'scaffold', 'templates', 'components'));

  await (0, _lib.asyncForEach)(components, component => {
    const outputComponentName = component.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.js');
    const finalFolder = (nestScaffoldByModel ? singularName + '/' : '') + outputComponentName.replace(/\.(js|tsx?)/, '');

    const outputPath = _path.default.join((0, _lib.getPaths)().web.components, pascalScaffoldPath, finalFolder, outputComponentName);

    const template = (0, _lib.generateTemplate)(_path.default.join('scaffold', 'templates', 'components', component), {
      name,
      columns,
      fieldsToImport,
      editableColumns,
      idType,
      intForeignKeys,
      pascalScaffoldPath,
      ...templateStrings
    });
    fileList[outputPath] = generateTypescript ? template : (0, _lib.transformTSToJS)(outputPath, template);
  });
  return fileList;
}; // add routes for all pages


const routes = async ({
  model: name,
  path: scaffoldPath = '',
  nestScaffoldByModel
}) => {
  if (typeof nestScaffoldByModel === 'undefined') {
    nestScaffoldByModel = (0, _internal.getConfig)().generate.nestScaffoldByModel;
  }

  const templateNames = getTemplateStrings(name, scaffoldPath);
  const singularPascalName = (0, _pascalcase.default)(_pluralize.default.singular(name));
  const pluralPascalName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const pluralParamName = (0, _paramCase.paramCase)(pluralPascalName);
  const model = await (0, _lib.getSchema)(singularPascalName);
  const idRouteParam = getIdType(model) === 'Int' ? ':Int' : '';
  const paramScaffoldPath = scaffoldPath === '' ? scaffoldPath : scaffoldPath.split('/').map(_paramCase.paramCase).join('/') + '/';
  const pascalScaffoldPath = (0, _pascalcase.default)(scaffoldPath);
  const pageRoot = pascalScaffoldPath + (nestScaffoldByModel ? singularPascalName : '');
  return [// new
  `<Route path="/${paramScaffoldPath}${pluralParamName}/new" page={${pageRoot}New${singularPascalName}Page} name="${templateNames.newRouteName}" />`, // edit
  `<Route path="/${paramScaffoldPath}${pluralParamName}/{id${idRouteParam}}/edit" page={${pageRoot}Edit${singularPascalName}Page} name="${templateNames.editRouteName}" />`, // singular
  `<Route path="/${paramScaffoldPath}${pluralParamName}/{id${idRouteParam}}" page={${pageRoot}${singularPascalName}Page} name="${templateNames.singularRouteName}" />`, // plural
  `<Route path="/${paramScaffoldPath}${pluralParamName}" page={${pageRoot}${pluralPascalName}Page} name="${templateNames.pluralRouteName}" />`];
};

exports.routes = routes;

const addRoutesInsideSetToRouter = async (model, path) => {
  const pluralPascalName = (0, _pascalcase.default)((0, _pluralize.default)(model));
  const layoutName = `${pluralPascalName}Layout`;
  return (0, _lib.addRoutesToRouterTask)(await routes({
    model,
    path
  }), layoutName);
};

const addLayoutImport = ({
  model: name,
  path: scaffoldPath = ''
}) => {
  const pluralPascalName = (0, _pascalcase.default)((0, _pluralize.default)(name));
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : scaffoldPath.split('/').map(_pascalcase.default).join('/') + '/';
  const layoutName = `${pluralPascalName}Layout`;
  const importLayout = `import ${pluralPascalName}Layout from 'src/layouts/${pascalScaffoldPath}${layoutName}'`;
  const routesPath = (0, _lib.getPaths)().web.routes;
  const routesContent = (0, _lib.readFile)(routesPath).toString();
  const newRoutesContent = routesContent.replace(/['"]@redwoodjs\/router['"](\s*)/, `'@redwoodjs/router'\n${importLayout}$1`);
  (0, _lib.writeFile)(routesPath, newRoutesContent, {
    overwriteExisting: true
  });
  return 'Added layout import to Routes.{js,tsx}';
};

const addSetImport = task => {
  const routesPath = (0, _lib.getPaths)().web.routes;
  const routesContent = (0, _lib.readFile)(routesPath).toString();
  const [redwoodRouterImport, importStart, spacing, importContent, importEnd] = routesContent.match(/(import {)(\s*)([^]*)(} from ['"]@redwoodjs\/router['"])/) || [];

  if (!redwoodRouterImport) {
    task.skip("Couldn't add Set import from @redwoodjs/router to Routes.{js,tsx}");
    return undefined;
  }

  const routerImports = importContent.replace(/\s/g, '').split(',');

  if (routerImports.includes(PACKAGE_SET)) {
    return 'Skipping Set import';
  }

  const newRoutesContent = routesContent.replace(redwoodRouterImport, importStart + spacing + PACKAGE_SET + `,` + spacing + importContent + importEnd);
  (0, _lib.writeFile)(routesPath, newRoutesContent, {
    overwriteExisting: true
  });
  return 'Added Set import to Routes.{js,tsx}';
};

const command = 'scaffold <model>';
exports.command = command;
const description = 'Generate Pages, SDL, and Services files based on a given DB schema Model. Also accepts <path/model>';
exports.description = description;

const builder = yargs => {
  yargs.positional('model', {
    description: "Model to scaffold. You can also use <path/model> to nest files by type at the given path directory (or directories). For example, 'rw g scaffold admin/post'"
  }).option('tests', {
    description: 'Generate test files',
    type: 'boolean'
  }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', 'https://redwoodjs.com/reference/command-line-interface#generate-scaffold')}`); // Merge generator defaults in

  Object.entries(_generate.yargsDefaults).forEach(([option, config]) => {
    yargs.option(option, config);
  });
};

exports.builder = builder;

const tasks = ({
  model,
  path,
  force,
  tests,
  typescript,
  javascript
}) => {
  return new _listr.default([{
    title: 'Generating scaffold files...',
    task: async () => {
      const f = await files({
        model,
        path,
        tests,
        typescript,
        javascript
      });
      return (0, _lib.writeFilesTask)(f, {
        overwriteExisting: force
      });
    }
  }, {
    title: 'Adding layout import...',
    task: async () => addLayoutImport({
      model,
      path
    })
  }, {
    title: 'Adding set import...',
    task: async (_, task) => addSetImport(task)
  }, {
    title: 'Adding scaffold routes...',
    task: async () => addRoutesInsideSetToRouter(model, path)
  }, {
    title: 'Adding scaffold asset imports...',
    task: () => (0, _lib.addScaffoldImport)()
  }], {
    collapse: false,
    exitOnError: true
  });
};

const handler = async ({
  model: modelArg,
  force,
  tests,
  typescript
}) => {
  if (modelArg.toLowerCase() === 'dbauth') {
    // proxy to dbAuth generator
    return await (0, _dbAuth.handler)({
      force,
      tests,
      typescript
    });
  }

  if (tests === undefined) {
    tests = (0, _internal.getConfig)().generate.tests;
  }

  const {
    model,
    path
  } = splitPathAndModel(modelArg);
  await (0, _helpers.ensureUniquePlural)({
    model
  });
  const t = tasks({
    model,
    path,
    force,
    tests,
    typescript
  });

  try {
    await t.run();
  } catch (e) {
    console.log(_colors.default.error(e.message));
    process.exit((e === null || e === void 0 ? void 0 : e.existCode) || 1);
  }
};

exports.handler = handler;

const splitPathAndModel = pathSlashModel => {
  const path = pathSlashModel.split('/').slice(0, -1).join('/'); // This code will work whether or not there's a path in model
  // E.g. if model is just 'post',
  // path.split('/') will return ['post'].

  const model = pathSlashModel.split('/').pop();
  return {
    model,
    path
  };
};

exports.splitPathAndModel = splitPathAndModel;