"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.builder = exports.description = exports.command = exports.graphFunctionDoesExist = exports.webIndexDoesExist = exports.apiSrcDoesExist = exports.isProviderSupported = exports.addApiConfig = exports.addConfigToApp = exports.files = void 0;

require("core-js/modules/esnext.weak-map.delete-all.js");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _execa = _interopRequireDefault(require("execa"));

var _listr = _interopRequireDefault(require("listr"));

var _prompts = _interopRequireDefault(require("prompts"));

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _internal = require("@redwoodjs/internal");

var _structure = require("@redwoodjs/structure");

var _lib = require("../../../lib");

var _colors = _interopRequireDefault(require("../../../lib/colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const AUTH_PROVIDER_IMPORT = `import { AuthProvider } from '@redwoodjs/auth'`;
const OUTPUT_PATHS = {
  auth: _path.default.join((0, _lib.getPaths)().api.lib, (0, _structure.getProject)().isTypeScriptProject ? 'auth.ts' : 'auth.js'),
  function: _path.default.join((0, _lib.getPaths)().api.functions, (0, _structure.getProject)().isTypeScriptProject ? 'auth.ts' : 'auth.js')
};

const getGraphqlPath = () => (0, _internal.resolveFile)(_path.default.join((0, _lib.getPaths)().api.functions, 'graphql'));

const getWebAppPath = () => (0, _lib.getPaths)().web.app;

const getSupportedProviders = () => _fs.default.readdirSync(_path.default.resolve(__dirname, 'providers')).map(file => _path.default.basename(file, '.js')).filter(file => file !== 'README.md');

const getTemplates = () => _fs.default.readdirSync(_path.default.resolve(__dirname, 'templates')).reduce((templates, file) => {
  if (file === 'auth.js.template') {
    return { ...templates,
      base: [_path.default.resolve(__dirname, 'templates', file)]
    };
  } else {
    const provider = file.split('.')[0];

    if (templates[provider]) {
      templates[provider].push(_path.default.resolve(__dirname, 'templates', file));
      return { ...templates
      };
    } else {
      return { ...templates,
        [provider]: [_path.default.resolve(__dirname, 'templates', file)]
      };
    }
  }
}, {}); // returns the content of App.{js,tsx} with import statements added


const addWebImports = (content, imports) => {
  return `${AUTH_PROVIDER_IMPORT}\n` + imports.join('\n') + '\n' + content;
}; // returns the content of App.{js,tsx} with init lines added (if there are any)


const addWebInit = (content, init) => {
  if (init) {
    return content.replace('const App = () => (', `${init}\n\nconst App = () => (`);
  } else {
    return content;
  }
};

const objectToComponentProps = (obj, options = {
  exclude: []
}) => {
  let props = [];

  for (const [key, value] of Object.entries(obj)) {
    if (!options.exclude.includes(key)) {
      if (key === 'client') {
        props.push(`${key}={${value}}`);
      } else {
        props.push(`${key}="${value}"`);
      }
    }
  }

  return props;
}; // returns the content of App.{js,tsx} with <AuthProvider> added


const addWebRender = (content, authProvider) => {
  const [_, indent, redwoodApolloProvider] = content.match(/(\s+)(<RedwoodApolloProvider>.*<\/RedwoodApolloProvider>)/s);
  const redwoodApolloProviderLines = redwoodApolloProvider.split('\n').map(line => {
    return '  ' + line;
  });
  const customRenderOpen = (authProvider.render || []).reduce((acc, component) => acc + indent + `<${component}>`, '');
  const customRenderClose = (authProvider.render || []).reduce((acc, component) => indent + `</${component}>` + acc, '');
  const props = objectToComponentProps(authProvider, {
    exclude: ['render']
  });
  const renderContent = customRenderOpen + indent + `<AuthProvider ${props.join(' ')}>` + indent + redwoodApolloProviderLines.join('\n') + indent + `</AuthProvider>` + customRenderClose;
  return content.replace(/\s+<RedwoodApolloProvider>.*<\/RedwoodApolloProvider>/s, renderContent);
}; // returns the content of App.{js,tsx} with <AuthProvider> updated


const updateWebRender = (content, authProvider) => {
  const props = objectToComponentProps(authProvider);
  const renderContent = `<AuthProvider ${props.join(' ')}>`;
  return content.replace(/<AuthProvider client={.*} type=".*">/s, renderContent);
}; // returns the content of App.{js,tsx} without the old auth import


const removeOldWebImports = (content, imports) => {
  return content.replace(`${AUTH_PROVIDER_IMPORT}\n` + imports.join('\n'), '');
}; // returns the content of App.{js,tsx} without the old auth init


const removeOldWebInit = (content, init) => {
  return content.replace(init, '');
}; // returns content with old auth provider removes


const removeOldAuthProvider = async content => {
  // get the current auth provider
  const [_, currentAuthProvider] = content.match(/<AuthProvider.*type=['"](.*)['"]/s);
  let oldAuthProvider;

  try {
    oldAuthProvider = await Promise.resolve(`./providers/${currentAuthProvider}`).then(s => _interopRequireWildcard(require(s)));
  } catch (e) {
    throw new Error('Could not replace existing auth provider init');
  }

  content = removeOldWebImports(content, oldAuthProvider.config.imports);
  content = removeOldWebInit(content, oldAuthProvider.config.init);
  return content;
}; // check to make sure AuthProvider doesn't exist


const checkAuthProviderExists = async () => {
  const content = _fs.default.readFileSync(getWebAppPath()).toString();

  if (content.includes(AUTH_PROVIDER_IMPORT)) {
    throw new Error('Existing auth provider found.\nUse --force to override existing provider.');
  }
}; // the files to create to support auth


const files = provider => {
  const templates = getTemplates();
  let files = {}; // look for any templates for this provider

  for (const [templateProvider, templateFiles] of Object.entries(templates)) {
    if (provider === templateProvider) {
      templateFiles.forEach(templateFile => {
        const outputPath = OUTPUT_PATHS[_path.default.basename(templateFile).split('.')[1]];

        files = Object.assign(files, {
          [outputPath]: _fs.default.readFileSync(templateFile).toString()
        });
      });
    }
  } // if there are no provider-specific templates, just use the base auth one


  if (Object.keys(files).length === 0) {
    files = {
      [OUTPUT_PATHS.auth]: _fs.default.readFileSync(templates.base[0]).toString()
    };
  }

  return files;
}; // actually inserts the required config lines into App.{js,tsx}


exports.files = files;

const addConfigToApp = async (config, force) => {
  const webAppPath = getWebAppPath();

  let content = _fs.default.readFileSync(webAppPath).toString(); // update existing AuthProvider if --force else add new AuthProvider


  if (content.includes(AUTH_PROVIDER_IMPORT) && force) {
    content = await removeOldAuthProvider(content);
    content = updateWebRender(content, config.authProvider);
  } else {
    content = addWebRender(content, config.authProvider);
  }

  content = addWebImports(content, config.imports);
  content = addWebInit(content, config.init);

  _fs.default.writeFileSync(webAppPath, content);
};

exports.addConfigToApp = addConfigToApp;

const addApiConfig = () => {
  const graphqlPath = getGraphqlPath();

  let content = _fs.default.readFileSync(graphqlPath).toString(); // default to an array to avoid destructure errors


  const [_, hasAuthImport] = content.match(/(import {.*} from 'src\/lib\/auth.*')/s) || [];

  if (!hasAuthImport) {
    // add import statement
    content = content.replace(/^(.*services.*)$/m, `$1\n\nimport { getCurrentUser } from 'src/lib/auth'`); // add object to handler

    content = content.replace(/^(\s*)(schema: makeMergedSchema)(.*)$/m, `$1getCurrentUser,\n$1$2$3`);

    _fs.default.writeFileSync(graphqlPath, content);
  }
};

exports.addApiConfig = addApiConfig;

const isProviderSupported = provider => {
  return getSupportedProviders().indexOf(provider) !== -1;
};

exports.isProviderSupported = isProviderSupported;

const apiSrcDoesExist = () => {
  return _fs.default.existsSync(_path.default.join((0, _lib.getPaths)().api.src));
};

exports.apiSrcDoesExist = apiSrcDoesExist;

const webIndexDoesExist = () => {
  return _fs.default.existsSync(getWebAppPath());
};

exports.webIndexDoesExist = webIndexDoesExist;

const graphFunctionDoesExist = () => {
  return _fs.default.existsSync(getGraphqlPath());
};

exports.graphFunctionDoesExist = graphFunctionDoesExist;
const command = 'auth <provider>';
exports.command = command;
const description = 'Generate an auth configuration';
exports.description = description;

const builder = yargs => {
  yargs.positional('provider', {
    choices: getSupportedProviders(),
    description: 'Auth provider to configure',
    type: 'string'
  }).option('force', {
    alias: 'f',
    default: false,
    description: 'Overwrite existing configuration',
    type: 'boolean'
  }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', 'https://redwoodjs.com/reference/command-line-interface#generate-auth')}`);
};

exports.builder = builder;

const handler = async ({
  provider,
  force
}) => {
  const providerData = await Promise.resolve(`./providers/${provider}`).then(s => _interopRequireWildcard(require(s))); // check if api/src/lib/auth.js already exists and if so, ask the user to overwrite

  if (force === false) {
    if (_fs.default.existsSync(Object.keys(files(provider))[0])) {
      const response = await (0, _prompts.default)({
        type: 'confirm',
        name: 'answer',
        message: `Overwrite existing ${(0, _lib.getPaths)().api.lib.replace((0, _lib.getPaths)().base, '')}/auth.[jt]s?`,
        initial: false
      });
      force = response.answer;
    }
  }

  const tasks = new _listr.default([{
    title: 'Generating auth lib...',
    task: (_ctx, task) => {
      if (apiSrcDoesExist()) {
        return (0, _lib.writeFilesTask)(files(provider), {
          overwriteExisting: force
        });
      } else {
        task.skip('api/src not found, skipping');
      }
    }
  }, {
    title: 'Adding auth config to web...',
    task: (_ctx, task) => {
      if (webIndexDoesExist()) {
        addConfigToApp(providerData.config, force);
      } else {
        task.skip('web/src/App.{js,tsx} not found, skipping');
      }
    }
  }, {
    title: 'Adding auth config to GraphQL API...',
    task: (_ctx, task) => {
      if (graphFunctionDoesExist()) {
        addApiConfig();
      } else {
        task.skip('GraphQL function not found, skipping');
      }
    }
  }, {
    title: 'Adding required web packages...',
    task: async () => {
      if (!isProviderSupported(provider)) {
        throw new Error(`Unknown auth provider '${provider}'`);
      }

      await (0, _execa.default)('yarn', ['workspace', 'web', 'add', ...providerData.webPackages, '@redwoodjs/auth']);
    }
  }, providerData.apiPackages.length > 0 && {
    title: 'Adding required api packages...',
    task: async () => {
      if (!isProviderSupported(provider)) {
        throw new Error(`Unknown auth provider '${provider}'`);
      }

      await (0, _execa.default)('yarn', ['workspace', 'api', 'add', ...providerData.apiPackages]);
    }
  }, {
    title: 'Installing packages...',
    task: async () => {
      await (0, _execa.default)('yarn', ['install']);
    }
  }, providerData.task, {
    title: 'One more thing...',
    task: (_ctx, task) => {
      task.title = `One more thing...\n\n   ${providerData.notes.join('\n   ')}\n`;
    }
  }].filter(Boolean), {
    collapse: false
  });

  try {
    // Don't throw existing provider error when --force exists
    if (!force) {
      await checkAuthProviderExists();
    }

    await tasks.run();
  } catch (e) {
    console.error(_colors.default.error(e.message));
    process.exit((e === null || e === void 0 ? void 0 : e.exitCode) || 1);
  }
};

exports.handler = handler;