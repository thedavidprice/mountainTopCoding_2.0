"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.requestHandler = exports.parseBody = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _qs = _interopRequireDefault(require("qs"));

var _error = require("../error");

const parseBody = rawBody => {
  if (typeof rawBody === 'string') {
    return {
      body: rawBody,
      isBase64Encoded: false
    };
  }

  if (rawBody instanceof Buffer) {
    return {
      body: rawBody.toString('base64'),
      isBase64Encoded: true
    };
  }

  return {
    body: '',
    isBase64Encoded: false
  };
};

exports.parseBody = parseBody;

const lambdaEventForExpressRequest = request => {
  return {
    httpMethod: request.method,
    headers: request.headers,
    path: request.path,
    queryStringParameters: _qs.default.parse(request.url.split(/\?(.+)/)[1]),
    requestContext: {
      identity: {
        sourceIp: request.ip
      }
    },
    ...parseBody(request.body) // adds `body` and `isBase64Encoded`

  };
};

const expressResponseForLambdaResult = (expressResFn, lambdaResult) => {
  const {
    statusCode = 200,
    headers,
    body = ''
  } = lambdaResult;

  if (headers) {
    var _context;

    (0, _forEach.default)(_context = (0, _keys.default)(headers)).call(_context, headerName => {
      const headerValue = headers[headerName];
      expressResFn.setHeader(headerName, headerValue);
    });
  }

  expressResFn.status(statusCode); // We're using this to log GraphQL errors, this isn't the right place.
  // I can't seem to get the express middleware to play nicely.

  if (statusCode === 400) {
    try {
      var _b$errors;

      const b = JSON.parse(body);

      if (b !== null && b !== void 0 && (_b$errors = b.errors) !== null && _b$errors !== void 0 && _b$errors[0]) {
        const {
          message
        } = b.errors[0];
        const e = new Error(message);
        e.stack = '';
        (0, _error.handleError)(e).then(console.error);
      }
    } catch (e) {// do nothing
    }
  } // The AWS lambda docs specify that the response object must be
  // compatible with `JSON.stringify`, but the type definition specifices that
  // it must be a string.


  if (typeof body === 'string') {
    expressResFn.send(body);
  } else {
    expressResFn.json(body);
  }
};

const expressResponseForLambdaError = (expressResFn, error) => {
  (0, _error.handleError)(error).then(console.log);
  expressResFn.status(500).send();
};

const requestHandler = async (req, res, handler) => {
  // We take the express request object and convert it into a lambda function event.
  const event = lambdaEventForExpressRequest(req);

  const handlerCallback = expressResFn => (error, lambdaResult) => {
    if (error) {
      expressResponseForLambdaError(expressResFn, error);
      return;
    }

    expressResponseForLambdaResult(expressResFn, lambdaResult);
  }; // Execute the lambda function.
  // https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html


  const handlerPromise = handler(event, // @ts-expect-error - Add support for context: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/0bb210867d16170c4a08d9ce5d132817651a0f80/types/aws-lambda/index.d.ts#L443-L467
  {}, handlerCallback(res)); // In this case the handlerCallback should not be called.

  if (handlerPromise && typeof handlerPromise.then === 'function') {
    try {
      const lambaResponse = await handlerPromise;
      return expressResponseForLambdaResult(res, lambaResponse);
    } catch (error) {
      return expressResponseForLambdaError(res, error);
    }
  }
};

exports.requestHandler = requestHandler;