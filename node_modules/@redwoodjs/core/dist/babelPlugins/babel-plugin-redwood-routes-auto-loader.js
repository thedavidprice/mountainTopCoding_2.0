"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = _default;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));

var _internal = require("@redwoodjs/internal");

var _generateGlobals = require("./generateGlobals");

var _generateTypes = require("./generateTypes");

// Use ' because I don't want to escape `
const RouteParameterTypeParser = 'type ParamType<constraint> = constraint extends "Int" ? number : constraint extends "Boolean" ? boolean : constraint extends "Float" ? number : string;' + '\n' + 'type RouteParams<Route> = Route extends `${string}/{${infer Param}:${infer Constraint}}/${infer Rest}` ? { [Entry in Param]: ParamType<Constraint> } & RouteParams<`/${Rest}`> : Route extends `${string}/{${infer Param}:${infer Constraint}}` ? { [Entry in Param]: ParamType<Constraint> } : Route extends `${string}/{${infer Param}}/${infer Rest}` ? { [Entry in Param]: string } & RouteParams<`/${Rest}`> : {}';

function _default({
  types: t
}, {
  project,
  useStaticImports = false
}) {
  let pages = (0, _internal.processPagesDir)();
  const rwPageImportPaths = (0, _map.default)(pages).call(pages, page => page.importPath);
  return {
    name: 'babel-plugin-redwood-routes-auto-loader',
    visitor: {
      // Remove any pages that have been explicitly imported in the Routes file,
      // because when one is present, the user is requesting that the module be
      // included in the main bundle.
      ImportDeclaration(p) {
        var _context;

        if (pages.length === 0) {
          return;
        } // Remove Page imports in prerender mode (see babel-preset)
        // This is to make sure that all the imported "Page modules" are normal imports
        // and not asynchronous ones.


        if (useStaticImports) {
          var _p$node$source;

          // Match import paths, const name could be different
          // NOTE: the userImportPath we receive at this point is the aboluste path
          // because of babel-plugin-module-resolver that runs before
          const userImportPath = (0, _internal.importStatementPath)((_p$node$source = p.node.source) === null || _p$node$source === void 0 ? void 0 : _p$node$source.value);

          if ((0, _includes.default)(rwPageImportPaths).call(rwPageImportPaths, userImportPath)) {
            p.remove();
          }

          return;
        }

        const declaredImports = (0, _map.default)(_context = p.node.specifiers).call(_context, specifier => specifier.local.name);
        pages = (0, _filter.default)(pages).call(pages, dep => !(0, _includes.default)(declaredImports).call(declaredImports, dep.const));
      },

      Program: {
        enter() {
          var _context2, _context3, _context4, _context5, _context6, _context7;

          pages = (0, _internal.processPagesDir)(); // Produces:
          // routes.home: () => "/home"
          // routes.aboutUs: () => "/about-us"

          const availableRoutes = (0, _map.default)(_context2 = (0, _filter.default)(_context3 = project.getRouter().routes).call(_context3, r => !r.isNotFound)).call(_context2, r => `${r.name}: (params?: RouteParams<"${r.path}"> & QueryParams) => "${r.path}"`);
          const pageImports = (0, _map.default)(pages).call(pages, page => `import type ${page.const}Type from '${page.importPath}'`);
          const pageGlobals = (0, _map.default)(pages).call(pages, page => `const ${page.const}: typeof ${page.const}Type`);
          const typeDefContent = (0, _map.default)(_context4 = (0, _slice.default)(_context5 = `
            import '@redwoodjs/router'

            ${RouteParameterTypeParser}
            type QueryParams = Record<string | number, string | number | boolean>

            declare module '@redwoodjs/router' {
              interface AvailableRoutes {
                ${availableRoutes.join('\n    ')}
              }
            }
            `.split('\n')).call(_context5, 1)).call(_context4, line => line.replace('            ', '')).join('\n');
          const globalsDefContent = (0, _map.default)(_context6 = (0, _slice.default)(_context7 = `
            ${pageImports.join('\n')}

            declare global {
              ${pageGlobals.join('\n  ')}
            }
            `.split('\n')).call(_context7, 1)).call(_context6, line => line.replace('            ', '')).join('\n');
          (0, _generateTypes.generateTypeDef)('routes.d.ts', typeDefContent);
          (0, _generateGlobals.generateGlobalsDef)('routes-globals.d.ts', globalsDefContent);
          (0, _generateTypes.generateTypeDefIndex)();
        },

        exit(p) {
          if (pages.length === 0) {
            return;
          }

          const nodes = []; // Prepend all imports to the top of the file

          for (const {
            importName,
            importPath
          } of pages) {
            // + const <importName> = { name: <importName>, loader: () => import(<importPath>) }
            nodes.push(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(importName), t.objectExpression([t.objectProperty(t.identifier('name'), t.stringLiteral(importName)), t.objectProperty(t.identifier('loader'), t.arrowFunctionExpression([], t.callExpression( // If useStaticImports, do a synchronous import with require (ssr/prerender)
            // otherwise do a dynamic import (browser)
            useStaticImports ? t.identifier('require') : t.identifier('import'), [t.stringLiteral(importPath)])))]))]));
          } // Insert at the top of the file


          p.node.body.unshift(...nodes);
        }

      }
    }
  };
}