"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = _default;

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));

var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));

var _path = _interopRequireDefault(require("path"));

var _paths = require("@redwoodjs/internal/dist/paths");

var _structure = require("@redwoodjs/structure");

function _default({
  types: t
}) {
  let nodesToRemove = [];
  let nodesToInsert = [];
  return {
    name: 'babel-plugin-redwood-mock-cell-data',
    visitor: {
      Program: {
        enter() {
          nodesToRemove = [];
          nodesToInsert = [];
        },

        exit(p) {
          for (const n of nodesToRemove) {
            n.remove();
          } // Insert at the top of the file


          p.node.body.unshift(...nodesToInsert);
        }

      },

      ExportNamedDeclaration(p, state) {
        var _context;

        // This converts a standard export into a "mockGraphQLQuery" by automatically:
        // Determining the query operation name for `QUERY` and,
        // wrapping the exported data in `afterQuery`
        //
        // Rules:
        // 1. Must be a *.mock.[ts,js] file.
        // 2. That has a named export called "standard".
        // 3. That are adjacent to a Cell.
        // 4. The Cell has a operation name for the QUERY export.
        const d = p.node.declaration;

        if ((d === null || d === void 0 ? void 0 : d.type) !== 'VariableDeclaration') {
          return;
        }

        const vd = d.declarations[0];
        const id = vd.id;
        const exportName = id === null || id === void 0 ? void 0 : id.name;

        if (exportName !== 'standard') {
          return;
        }

        const init = vd === null || vd === void 0 ? void 0 : vd.init;

        if (!init) {
          return;
        } // Find the model of the Cell that is in the same directory.


        const filename = state.file.opts.filename;
        const dir = (0, _structure.URL_file)(_path.default.dirname(state.file.opts.filename));
        const project = (0, _structure.getProject)((0, _paths.getBaseDirFromFile)(filename));
        const cell = (0, _find.default)(_context = project.cells).call(_context, x => {
          var _context2;

          return (0, _startsWith.default)(_context2 = x.uri).call(_context2, dir);
        });

        if (!cell || !(cell !== null && cell !== void 0 && cell.filePath)) {
          return;
        }

        if (!cell.queryOperationName) {
          return;
        } // export const standard


        const exportStandard = ex => t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('standard'), ex)])); // mockGraphQLQuery(<operationName>, <data>)


        const mockGraphQLCall = t.callExpression(t.identifier('mockGraphQLQuery'), [t.stringLiteral(cell.queryOperationName), init]); // Delete original "export const standard"

        nodesToRemove = [...nodesToRemove, p]; // + import { afterQuery } from './${cellFileName}'
        // + export const standard = () => afterQuery(...)

        if (cell.exportedSymbols.has('afterQuery')) {
          const importAfterQuery = t.importDeclaration([t.importSpecifier(t.identifier('afterQuery'), t.identifier('afterQuery'))], t.stringLiteral(`./${_path.default.basename(cell.filePath)}`));
          nodesToInsert = [...nodesToInsert, importAfterQuery, exportStandard(t.arrowFunctionExpression([], t.callExpression(t.identifier('afterQuery'), [t.callExpression(mockGraphQLCall, [])])))];
        } else {
          // + export const standard = mo
          nodesToInsert = [...nodesToInsert, exportStandard(mockGraphQLCall)];
        }
      }

    }
  };
}