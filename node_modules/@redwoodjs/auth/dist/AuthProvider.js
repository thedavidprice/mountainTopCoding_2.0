"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.AuthProvider = exports.AuthContext = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/json/stringify"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/some"));

var _react = _interopRequireDefault(require("react"));

var _authClients = require("./authClients");

// @ts-expect-error - We do not supply default values for the functions.
const AuthContext = /*#__PURE__*/_react.default.createContext({
  loading: true,
  isAuthenticated: false,
  userMetadata: null,
  currentUser: null
});

exports.AuthContext = AuthContext;

/**
 * @example
 * ```js
 *  const client = new Auth0Client(options)
 *  // ...
 *  <AuthProvider client={client} type="auth0" skipFetchCurrentUser={true}>
 *    {children}
 *  </AuthProvider>
 * ```
 */
class AuthProvider extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      loading: true,
      isAuthenticated: false,
      userMetadata: null,
      currentUser: null,
      hasError: false
    };
    this.rwClient = void 0;

    this.getCurrentUser = async () => {
      // Always get a fresh token, rather than use the one in state
      const token = await this.getToken();
      const response = await global.fetch(`${global.__REDWOOD__API_PROXY_PATH}/graphql`, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'auth-provider': this.rwClient.type,
          authorization: `Bearer ${token}`
        },
        body: (0, _stringify.default)({
          query: 'query __REDWOOD__AUTH_GET_CURRENT_USER { redwood { currentUser } }'
        })
      });

      if (response.ok) {
        var _data$redwood;

        const {
          data
        } = await response.json();
        return data === null || data === void 0 ? void 0 : (_data$redwood = data.redwood) === null || _data$redwood === void 0 ? void 0 : _data$redwood.currentUser;
      } else {
        throw new Error(`Could not fetch current user: ${response.statusText} (${response.status})`);
      }
    };

    this.hasRole = role => {
      if (typeof role !== 'undefined' && this.state.currentUser && this.state.currentUser.roles) {
        if (typeof role === 'string') {
          var _this$state$currentUs;

          return ((_this$state$currentUs = this.state.currentUser.roles) === null || _this$state$currentUs === void 0 ? void 0 : (0, _includes.default)(_this$state$currentUs).call(_this$state$currentUs, role)) || false;
        }

        if ((0, _isArray.default)(role)) {
          var _context;

          return (0, _some.default)(_context = this.state.currentUser.roles).call(_context, r => (0, _includes.default)(role).call(role, r));
        }
      }

      return false;
    };

    this.getToken = async () => {
      return this.rwClient.getToken();
    };

    this.reauthenticate = async () => {
      const notAuthenticatedState = {
        isAuthenticated: false,
        currentUser: null,
        userMetadata: null,
        loading: false,
        hasError: false
      };

      try {
        const userMetadata = await this.rwClient.getUserMetadata();

        if (!userMetadata) {
          this.setState(notAuthenticatedState);
        } else {
          await this.getToken();
          const currentUser = this.props.skipFetchCurrentUser ? null : await this.getCurrentUser();
          this.setState({ ...this.state,
            userMetadata,
            currentUser,
            isAuthenticated: true,
            loading: false
          });
        }
      } catch (e) {
        this.setState({ ...notAuthenticatedState,
          hasError: true,
          error: e
        });
      }
    };

    this.logIn = async options => {
      const loginOutput = await this.rwClient.login(options);
      await this.reauthenticate();
      return loginOutput;
    };

    this.logOut = async options => {
      await this.rwClient.logout(options);
      this.setState({
        userMetadata: null,
        currentUser: null,
        isAuthenticated: false,
        hasError: false,
        error: undefined
      });
    };

    this.signUp = async options => {
      const signupOutput = await this.rwClient.signup(options);
      await this.reauthenticate();
      return signupOutput;
    };

    this.rwClient = (0, _authClients.createAuthClient)(props.client, props.type);
  }

  async componentDidMount() {
    var _this$rwClient$restor, _this$rwClient;

    await ((_this$rwClient$restor = (_this$rwClient = this.rwClient).restoreAuthState) === null || _this$rwClient$restor === void 0 ? void 0 : _this$rwClient$restor.call(_this$rwClient));
    return this.reauthenticate();
  }

  render() {
    const {
      client,
      type,
      children
    } = this.props;
    return /*#__PURE__*/_react.default.createElement(AuthContext.Provider, {
      value: { ...this.state,
        logIn: this.logIn,
        logOut: this.logOut,
        signUp: this.signUp,
        getToken: this.getToken,
        getCurrentUser: this.getCurrentUser,
        hasRole: this.hasRole,
        reauthenticate: this.reauthenticate,
        client,
        type
      }
    }, children);
  }

}

exports.AuthProvider = AuthProvider;
AuthProvider.defaultProps = {
  skipFetchCurrentUser: false
};