"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RWLanguageServer = void 0;

var _vscodeLanguageserver = require("vscode-languageserver");

var _vscodeLanguageserverTextdocument = require("vscode-languageserver-textdocument");

var _ide = require("../ide");

var _model = require("../model");

var _decorators = require("../x/decorators");

var _URL = require("../x/URL");

var _vscode = require("../x/vscode");

var _vscodeLanguageserver2 = require("../x/vscode-languageserver");

var _vscodeLanguageserverTypes = require("../x/vscode-languageserver-types");

var _commands = require("./commands");

var _diagnostics = require("./diagnostics");

var _outline = require("./outline");

var _xmethods = require("./xmethods");

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

let RWLanguageServer = (_dec = (0, _decorators.lazy)(), _dec2 = (0, _decorators.memo)(), _dec3 = (0, _decorators.lazy)(), _dec4 = (0, _decorators.lazy)(), _dec5 = (0, _decorators.lazy)(), _dec6 = (0, _decorators.lazy)(), _dec7 = (0, _decorators.lazy)(), (_class = class RWLanguageServer {
  constructor() {
    this.documents = new _vscodeLanguageserver.TextDocuments(_vscodeLanguageserverTextdocument.TextDocument);
  }

  get connection() {
    const c = (0, _vscodeLanguageserver.createConnection)(_vscodeLanguageserver.ProposedFeatures.all);
    (0, _vscodeLanguageserver2.Connection_suppressErrors)(c);
    return c;
  }

  start() {
    const {
      connection,
      documents
    } = this;
    connection.onInitialize(params => {
      connection.console.log(`Redwood Language Server onInitialize(), PID=${process.pid}`);
      this.initializeParams = params;
      return {
        capabilities: {
          textDocumentSync: {
            openClose: true,
            change: _vscodeLanguageserver.TextDocumentSyncKind.Full
          },
          implementationProvider: true,
          definitionProvider: true,
          codeActionProvider: true,
          codeLensProvider: {
            resolveProvider: false
          },
          executeCommandProvider: this.commands.options,
          documentLinkProvider: {
            resolveProvider: false
          },
          hoverProvider: true
        }
      };
    });
    connection.onInitialized(async () => {
      connection.console.log('Redwood Language Server onInitialized()');
      const folders = await connection.workspace.getWorkspaceFolders();

      if (folders) {
        for (const folder of folders) {
          this.projectRoot = (0, _URL.URL_toFile)(folder.uri);
        }
      }
    }); // initialize these early on to prevent "unhandled methods"
    // they are smart enough to short-circuit if this.projectRoot is not ready

    this.diagnostics.start();
    this.commands.start();
    this.outline.start();
    this.xmethods.start();
    connection.onImplementation(async ({
      textDocument: {
        uri
      },
      position
    }) => {
      const info = await this.info(uri, 'Implementation');

      for (const i of info) {
        if ((0, _vscodeLanguageserverTypes.Range_contains)(i.location.range, position)) {
          return i.target;
        }
      }
    });
    connection.onDefinition(async ({
      textDocument: {
        uri
      },
      position
    }) => {
      const info = await this.info(uri, 'Definition');

      for (const i of info) {
        if ((0, _vscodeLanguageserverTypes.Range_contains)(i.location.range, position)) {
          return i.target;
        }
      }
    });
    connection.onDocumentLinks(async ({
      textDocument: {
        uri
      }
    }) => {
      return (await this.info(uri, 'DocumentLink')).map(i => i.link);
    });
    connection.onCodeAction(async ({
      context,
      textDocument: {
        uri
      }
    }) => {
      var _this$getProject;

      const actions = [];
      const node = await ((_this$getProject = this.getProject()) === null || _this$getProject === void 0 ? void 0 : _this$getProject.findNode(uri));

      if (!node) {
        return [];
      }

      if (context.diagnostics.length > 0) {
        // find quick-fixes associated to diagnostics
        const xds = await node.collectDiagnostics();

        for (const xd of xds) {
          const as = await (0, _vscodeLanguageserverTypes.ExtendedDiagnostic_findRelevantQuickFixes)(xd, context);

          for (const a of as) {
            actions.push(a);
          }
        }
      }

      return actions;
    });
    connection.onCodeLens(async ({
      textDocument: {
        uri
      }
    }) => {
      return (await this.info(uri, 'CodeLens')).map(i => i.codeLens);
    });
    connection.onHover(async ({
      textDocument: {
        uri
      },
      position
    }) => {
      const info = await this.info(uri, 'Hover');

      for (const i of info) {
        if ((0, _vscodeLanguageserverTypes.Range_contains)(i.hover.range, position)) {
          return i.hover;
        }
      }
    });
    documents.listen(connection);
    connection.listen();
  }

  get diagnostics() {
    return new _diagnostics.DiagnosticsManager(this);
  }

  get commands() {
    return new _commands.CommandsManager(this);
  }

  get outline() {
    return new _outline.OutlineManager(this);
  }

  get xmethods() {
    return new _xmethods.XMethodsManager(this);
  }

  get host() {
    return new _ide.HostWithDocumentsStore(this.documents);
  }

  getProject() {
    if (!this.projectRoot) {
      return undefined;
    }

    return new _model.RWProject({
      projectRoot: this.projectRoot,
      host: this.host
    });
  }

  get vscodeWindowMethods() {
    return (0, _vscode.VSCodeWindowMethods_fromConnection)(this.connection);
  }

  async collectIDEInfo(uri) {
    var _await$this$getProjec, _this$getProject2;

    return (_await$this$getProjec = await ((_this$getProject2 = this.getProject()) === null || _this$getProject2 === void 0 ? void 0 : _this$getProject2.collectIDEInfo(uri))) !== null && _await$this$getProjec !== void 0 ? _await$this$getProjec : [];
  }

  async info(uri, kind) {
    return (await this.collectIDEInfo(uri)).filter(i => i.kind === kind);
  }

  get hasWorkspaceFolderCapability() {
    var _this$initializeParam;

    return ((_this$initializeParam = this.initializeParams.capabilities.workspace) === null || _this$initializeParam === void 0 ? void 0 : _this$initializeParam.workspaceFolders) === true;
  }

}, (_applyDecoratedDescriptor(_class.prototype, "connection", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "connection"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "start", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "start"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "diagnostics", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "diagnostics"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "commands", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "commands"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "outline", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "outline"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "xmethods", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "xmethods"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "host", [_dec7], Object.getOwnPropertyDescriptor(_class.prototype, "host"), _class.prototype)), _class));
exports.RWLanguageServer = RWLanguageServer;