"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

_Object$defineProperty(exports, "FormError", {
  enumerable: true,
  get: function () {
    return _FormError.default;
  }
});

exports.WeekField = exports.UrlField = exports.TimeField = exports.TextField = exports.TelField = exports.SubmitField = exports.SearchField = exports.ResetField = exports.RangeField = exports.RadioField = exports.PasswordField = exports.NumberField = exports.MonthField = exports.ImageField = exports.HiddenField = exports.FileField = exports.EmailField = exports.DatetimeLocalField = exports.DateField = exports.ColorField = exports.ButtonField = exports.Submit = exports.SelectField = exports.TextAreaField = exports.Label = exports.InputField = exports.FieldError = exports.FieldErrorContext = exports.Form = exports.CheckboxField = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));

var _react = _interopRequireWildcard(require("react"));

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _reactHookForm = require("react-hook-form");

var _coercion = require("./coercion");

var _FormError = _interopRequireDefault(require("./FormError"));

var _context2;

const DEFAULT_MESSAGES = {
  required: 'is required',
  pattern: 'is not formatted correctly',
  minLength: 'is too short',
  maxLength: 'is too long',
  min: 'is too low',
  max: 'is too high',
  validate: 'is not valid'
};
var INPUT_TYPES; // Massages a hash of props depending on whether the given named field has
// any errors on it

(function (INPUT_TYPES) {
  INPUT_TYPES["BUTTON"] = "button";
  INPUT_TYPES["COLOR"] = "color";
  INPUT_TYPES["DATE"] = "date";
  INPUT_TYPES["DATETIME_LOCAL"] = "datetime-local";
  INPUT_TYPES["EMAIL"] = "email";
  INPUT_TYPES["FILE"] = "file";
  INPUT_TYPES["HIDDEN"] = "hidden";
  INPUT_TYPES["IMAGE"] = "image";
  INPUT_TYPES["MONTH"] = "month";
  INPUT_TYPES["NUMBER"] = "number";
  INPUT_TYPES["PASSWORD"] = "password";
  INPUT_TYPES["RADIO"] = "radio";
  INPUT_TYPES["RANGE"] = "range";
  INPUT_TYPES["RESET"] = "reset";
  INPUT_TYPES["SEARCH"] = "search";
  INPUT_TYPES["SUBMIT"] = "submit";
  INPUT_TYPES["TEL"] = "tel";
  INPUT_TYPES["TEXT"] = "text";
  INPUT_TYPES["TIME"] = "time";
  INPUT_TYPES["URL"] = "url";
  INPUT_TYPES["WEEK"] = "week";
})(INPUT_TYPES || (INPUT_TYPES = {}));

const inputTagProps = props => {
  // eslint-disable-next-line react-hooks/rules-of-hooks
  const {
    errors,
    setError
  } = (0, _reactHookForm.useFormContext)(); // Check for errors from server and set on field if present
  // eslint-disable-next-line react-hooks/rules-of-hooks

  const fieldErrorsContext = (0, _react.useContext)(FieldErrorContext);
  const contextError = fieldErrorsContext[props.name]; // eslint-disable-next-line react-hooks/rules-of-hooks

  _react.default.useEffect(() => {
    if (contextError) {
      setError(props.name, {
        type: 'server',
        message: contextError
      });
    }
  }, [contextError, props.name, setError]); // any errors on this field


  const validationError = errors[props.name]; // get errorStyle/errorClassName and replace style/className if present
  // Also remove dataType and transformValue from tagProps

  const {
    errorClassName,
    errorStyle,
    dataType,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    transformValue,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    ...tagProps
  } = props;

  if (validationError) {
    if (errorClassName) {
      tagProps.className = errorClassName;
    }

    if (errorStyle) {
      tagProps.style = errorStyle;
    }
  }

  return tagProps;
}; // Context for keeping track of errors from the server


const FieldErrorContext = /*#__PURE__*/_react.default.createContext({});

exports.FieldErrorContext = FieldErrorContext;

const coerceValues = (data, coerce) => {
  var _context;

  const coercedData = {};
  (0, _forEach.default)(_context = (0, _keys.default)(data)).call(_context, name => {
    coercedData[name] = coerce(name, data[name]);
  });
  return coercedData;
};

const FormWithCoercionContext = props => {
  var _errorProps$graphQLEr, _errorProps$graphQLEr2, _errorProps$graphQLEr3;

  // deconstruct some props we care about and keep the remaining `formProps` to
  // pass to the <form> tag
  const {
    error: errorProps,
    formMethods: propFormMethods,
    onSubmit,
    ...formProps
  } = props;
  const useFormMethods = (0, _reactHookForm.useForm)(props.validation);
  const formMethods = propFormMethods || useFormMethods;
  const {
    coerce
  } = (0, _coercion.useCoercion)();
  return /*#__PURE__*/_react.default.createElement("form", (0, _extends2.default)({}, formProps, {
    onSubmit: formMethods.handleSubmit((data, event) => onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(coerceValues(data, coerce), event))
  }), /*#__PURE__*/_react.default.createElement(FieldErrorContext.Provider, {
    value: (errorProps === null || errorProps === void 0 ? void 0 : (_errorProps$graphQLEr = errorProps.graphQLErrors[0]) === null || _errorProps$graphQLEr === void 0 ? void 0 : (_errorProps$graphQLEr2 = _errorProps$graphQLEr.extensions) === null || _errorProps$graphQLEr2 === void 0 ? void 0 : (_errorProps$graphQLEr3 = _errorProps$graphQLEr2.exception) === null || _errorProps$graphQLEr3 === void 0 ? void 0 : _errorProps$graphQLEr3.messages) || {}
  }, /*#__PURE__*/_react.default.createElement(_reactHookForm.FormProvider, formMethods, props.children)));
}; // Renders a containing <form> tag with required contexts


const Form = props => {
  return /*#__PURE__*/_react.default.createElement(_coercion.CoercionContextProvider, null, /*#__PURE__*/_react.default.createElement(FormWithCoercionContext, props));
}; // Renders a <label> tag that can be styled differently if errors are present
// on the related fields


exports.Form = Form;

const Label = props => {
  const tagProps = inputTagProps(props);
  return /*#__PURE__*/_react.default.createElement("label", (0, _extends2.default)({
    htmlFor: props.name
  }, tagProps), props.children || props.name);
}; // Renders a <span> with a validation error message if there is an error on this
// field


exports.Label = Label;

const FieldError = props => {
  const {
    errors
  } = (0, _reactHookForm.useFormContext)();
  const validationError = errors[props.name];
  const errorMessage = validationError && (validationError.message || `${props.name} ${DEFAULT_MESSAGES[validationError.type]}`);
  return validationError ? /*#__PURE__*/_react.default.createElement("span", props, errorMessage) : null;
};

exports.FieldError = FieldError;

const jsonValidation = value => {
  try {
    JSON.parse(value);
  } catch (e) {
    return e.message;
  }
}; // Renders a <textarea> field


const TextAreaField = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    register
  } = (0, _reactHookForm.useFormContext)();
  const {
    setCoercion
  } = (0, _coercion.useCoercion)();

  _react.default.useEffect(() => {
    if (props.dataType !== undefined && (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')) {
      console.warn('Using the "dataType" prop on form input fields is deprecated. Use "transformValue" instead.');
    }

    setCoercion({
      name: props.name,
      transformValue: props.transformValue || props.dataType
    });
  }, [setCoercion, props.name, props.transformValue, props.dataType]);

  const tagProps = inputTagProps(props); // implements JSON validation if a transformValue of 'Json' is set

  const validation = props.validation ? props.validation : {
    required: false
  };

  if (!validation.validate && props.transformValue === 'Json') {
    validation.validate = jsonValidation;
  }

  return /*#__PURE__*/_react.default.createElement("textarea", (0, _extends2.default)({}, tagProps, {
    id: props.id || props.name,
    ref: element => {
      register(element, validation);

      if (typeof ref === 'function') {
        ref(element);
      } else if (ref) {
        ref.current = element;
      }
    }
  }));
}); // Renders a <select> field

exports.TextAreaField = TextAreaField;
const SelectField = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    register
  } = (0, _reactHookForm.useFormContext)();
  const {
    setCoercion
  } = (0, _coercion.useCoercion)();

  _react.default.useEffect(() => {
    setCoercion({
      name: props.name,
      transformValue: props.transformValue
    });
  }, [setCoercion, props.name, props.transformValue]);

  const tagProps = inputTagProps(props);
  return /*#__PURE__*/_react.default.createElement("select", (0, _extends2.default)({}, tagProps, {
    id: props.id || props.name,
    ref: element => {
      register(element, props.validation || {
        required: false
      });

      if (typeof ref === 'function') {
        ref(element);
      } else if (ref) {
        ref.current = element;
      }
    }
  }));
}); // Renders a <input type="checkbox"> field

exports.SelectField = SelectField;
const CheckboxField = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    register
  } = (0, _reactHookForm.useFormContext)();
  const {
    setCoercion
  } = (0, _coercion.useCoercion)();
  const type = 'checkbox';

  _react.default.useEffect(() => {
    if (props.dataType !== undefined && (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')) {
      console.warn('Using the "dataType" prop on form input fields is deprecated. Use "transformValue" instead.');
    }

    setCoercion({
      name: props.name,
      type,
      transformValue: props.transformValue || props.dataType
    });
  }, [setCoercion, props.name, type, props.transformValue, props.dataType]);

  const tagProps = inputTagProps(props);
  return /*#__PURE__*/_react.default.createElement("input", (0, _extends2.default)({
    type: "checkbox"
  }, tagProps, {
    id: props.id || props.name,
    ref: element => {
      register(element, props.validation || {
        required: false
      });

      if (typeof ref === 'function') {
        ref(element);
      } else if (ref) {
        ref.current = element;
      }
    }
  }));
}); // Renders a <button type="submit">

exports.CheckboxField = CheckboxField;
const Submit = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({
  ref: ref,
  type: "submit"
}, props))); // Renders a <input>

exports.Submit = Submit;
const InputField = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    register
  } = (0, _reactHookForm.useFormContext)();
  const {
    setCoercion
  } = (0, _coercion.useCoercion)();

  _react.default.useEffect(() => {
    if (props.dataType !== undefined && (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')) {
      console.warn('Using the "dataType" prop on form input fields is deprecated. Use "transformValue" instead.');
    }

    setCoercion({
      name: props.name,
      type: props.type,
      transformValue: props.transformValue || props.dataType
    });
  }, [setCoercion, props.name, props.type, props.transformValue, props.dataType]);

  const tagProps = inputTagProps(props);
  return /*#__PURE__*/_react.default.createElement("input", (0, _extends2.default)({}, tagProps, {
    id: props.id || props.name,
    ref: element => {
      register(element, props.validation || {
        required: false
      });

      if (typeof ref === 'function') {
        ref(element);
      } else if (ref) {
        ref.current = element;
      }
    }
  }));
}); // Create a component for each type of Input.
//
// Uses a bit of Javascript metaprogramming to create the functions with a dynamic
// name rather than having to write out each and every component definition. In
// simple terms it creates an object with the key being the current value of `type`
// and then immediately returns the value, which is the component function definition.
//
// In the end we end up with `inputComponents.TextField` and all the others. Export those
// and we're good to go.

exports.InputField = InputField;
const inputComponents = {};
(0, _forEach.default)(_context2 = (0, _values.default)(INPUT_TYPES)).call(_context2, type => {
  inputComponents[`${(0, _pascalcase.default)(type)}Field`] = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => /*#__PURE__*/_react.default.createElement(InputField, (0, _extends2.default)({
    ref: ref,
    type: type
  }, props)));
});
const {
  ButtonField,
  ColorField,
  DateField,
  DatetimeLocalField,
  EmailField,
  FileField,
  HiddenField,
  ImageField,
  MonthField,
  NumberField,
  PasswordField,
  RadioField,
  RangeField,
  ResetField,
  SearchField,
  SubmitField,
  TelField,
  TextField,
  TimeField,
  UrlField,
  WeekField
} = inputComponents;
exports.WeekField = WeekField;
exports.UrlField = UrlField;
exports.TimeField = TimeField;
exports.TextField = TextField;
exports.TelField = TelField;
exports.SubmitField = SubmitField;
exports.SearchField = SearchField;
exports.ResetField = ResetField;
exports.RangeField = RangeField;
exports.RadioField = RadioField;
exports.PasswordField = PasswordField;
exports.NumberField = NumberField;
exports.MonthField = MonthField;
exports.ImageField = ImageField;
exports.HiddenField = HiddenField;
exports.FileField = FileField;
exports.EmailField = EmailField;
exports.DatetimeLocalField = DatetimeLocalField;
exports.DateField = DateField;
exports.ColorField = ColorField;
exports.ButtonField = ButtonField;