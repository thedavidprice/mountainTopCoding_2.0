"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _internal = require("@redwoodjs/internal");

/**
 * @fileoverview Rule to flag references to non-existent Pages.
 * @author Tom Preston-Werner
 *
 * Check to make sure that all referenced Pages exist in the `/web/src/pages`
 * directory. Thanks to eslint/undef upon which this code is based.
 */

/**
 * Checks if the given node is the argument of a typeof operator.
 * @param {ASTNode} node The AST node being checked.
 * @returns {boolean} Whether or not the node is the argument of a typeof operator.
 */
function hasTypeOfOperator(node) {
  const parent = node.parent;
  return parent.type === 'UnaryExpression' && parent.operator === 'typeof';
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


var _default = {
  meta: {
    type: 'problem',
    docs: {
      description: 'disallow the use of non-existent Pages in Routes file',
      category: 'Variables',
      recommended: true
    },
    schema: [{
      type: 'object',
      properties: {
        typeof: {
          type: 'boolean',
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      undef: "'{{name}}' can not be found in '/web/src/pages'."
    }
  },

  create(context) {
    const options = context.options[0];
    const considerTypeOf = options && options.typeof === true || false;
    const deps = (0, _internal.processPagesDir)();
    const pageConsts = (0, _map.default)(deps).call(deps, dep => dep.const);
    return {
      'Program:exit'()
      /* node */
      {
        var _context;

        const globalScope = context.getScope();
        (0, _forEach.default)(_context = globalScope.through).call(_context, ref => {
          const identifier = ref.identifier;

          if (!considerTypeOf && hasTypeOfOperator(identifier)) {
            return;
          }

          if (!(0, _includes.default)(pageConsts).call(pageConsts, identifier.name)) {
            context.report({
              node: identifier,
              messageId: 'undef',
              data: identifier
            });
          }
        });
      }

    };
  }

};
exports.default = _default;